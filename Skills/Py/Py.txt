Task:
Установка Python
Decision:
- https://www.python.org/ftp/python/3.10.2/python-3.10.2-amd64.exe - Downloads - Add Python 3.x to PATH - install now
Task:
Установка Python 3 в Ubuntu 20.04
Decision:
$ python3 --version
    Python 3.8.10
$ sudo apt update
$ sudo apt -y upgrade
$ sudo apt install software-properties-common -y
$ sudo add-apt-repository ppa:deadsnakes/ppa
$ sudo apt install python3.10 -y
$ sudo apt install python3-pip -y
$ python3.10 -V
    Python 3.10.2
$ python3 -V
    Python 3.8.10
$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1
    update-alternatives: используется /usr/bin/python3.8 для предоставления /usr/bin/python3 (python3) в автоматическом режиме
$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 2
$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 2
$ update-alternatives --list python3
    /usr/bin/python3.10
    /usr/bin/python3.8
$ sudo update-alternatives --config python3
    Есть 2 варианта для альтернативы python3 (предоставляет /usr/bin/python3).
      Выбор   Путь             Приор Состояние
    ------------------------------------------------------------
    * 0            /usr/bin/python3.8    10        автоматический режим
      1            /usr/bin/python3.10   2         ручной режим
      2            /usr/bin/python3.8    10        ручной режим
Press <enter> to keep the current choice[*], or type selection number: 1
    update-alternatives: используется /usr/bin/python3.10 для предоставления /usr/bin/python3 (python3) в ручном режиме
$ python3 -V
    Python 3.10.2
$ sudo apt-get install idle3 -y
$ vim test0.py
$ cat test0.py
print('Мы изучаем язык Python')
$ python3 test0.py
    Мы изучаем язык Python
$ idle
Task:
Установка Pip в CentOS 8
Decision:
# dnf install python3-paramiko -y
# pip3 --version
# python3 --version
# sudo yum install python3-devel -y
# sudo yum groupinstall 'development tools'
Task:
Установка PyQt5, создание первого GUI приложения
Decision:
- https://pypi.org/project/PyQt5/ - cmd - от имени администратора
- C:\Windows\system32>pip install PyQt5
- https://build-system.fman.io/static/public/files/Qt%20Designer%20Setup.exe - Запуск - install - ok - Запуск программы QT - Dialog with Buttons Bottom - create - Widget BoX - List View> - Group Box> - push buttom> - Check box> -Text Edit> - save - .ui - запуск программы idle python - save - .py - (https://build-system.fman.io/qt-designer-download)
from PyQt5 import uic
from PyQt5.QtWidgets import QApplication
Form, Window = uic.loadUiType("testqt0.ui")
app = QApplication([])
window = Window()
form = Form()
form.setupUi(window)
window.show()
app.exec()
- run
$ idle
Task:
Запись Данных В Csv-Файл
Decision:
$ python3 -m venv Py-WritingDataToACsvFile
$ source Py-WritingDataToACsvFile/bin/activate
$ vim Py-WritingDataToACsvFile.py
$ python Py-WritingDataToACsvFile.py
$ ls
Py-EncryptPdfPswwd
Py-EncryptionPasswordProtectionOfPdfFiles.py
Py-WritingDataToACsvFiledata.csv
$ cat Py-WritingDataToACsvFile.py
import csv
name_1="Anna"
name_2="Victor"
with open("data.csv","w") as file:
    writer=csv.writer(file)
    writer.writerow(
        [name_1, name_2]
    )
$ vim Py-WritingDataToACsvFilee.py
$ python Py-WritingDataToACsvFile.py
$ cat Py-WritingDataToACsvFile.py
import csv
name_1="Anna"
name_2="Victor"
data_names=["Oleg", "Vera"]
with open("data.csv","w") as file:
    writer=csv.writer(file)
    writer.writerow(
        #[name_1, name_2]
        data_names
    )
$ vim Py-WritingDataToACsvFile.py
$ python Py-WritingDataToACsvFile.py
$ cat Py-WritingDataToACsvFile.py
import csv
name_1="Anna"
name_2="Victor"
data_names=["Oleg", "Vera"]
with open("data.csv","w") as file:
    writer=csv.writer(file)
    writer.writerow(
        #[name_1, name_2]
        #data_names
        ("user_name", "user_address")
    )
users_data=[
    ["user1","address1"],
    ["user2","address2"],
    ["user3","address3"],
]
for user in users_data:
    with open("data.csv", "a") as file:
        writer=csv.writer(file)
        writer.writerow(
            user
        )
$ python Py-WritingDataToACsvFile.py
user_name,user_address
user1,address1
user2,address2
user3,address3
$ vim Py-WritingDataToACsvFile.py
$ python Py-WritingDataToACsvFile.py
$ cat Py-WritingDataToACsvFile.py
import csv
name_1="Anna"
name_2="Victor"
data_names=["Oleg", "Vera"]
'''with open("data.csv","w") as file:
    writer=csv.writer(file)
    writer.writerow(
        #[name_1, name_2]
        #data_names
        ("user_name", "user_address")
    )'''
users_data=[
    ("user_name","user_address"),
    ["user1","address1"],
    ["user2","address2"],
    ["user3","address3"],
]
'''for user in users_data:
    with open("data.csv", "a") as file:
        writer=csv.writer(file)
        writer.writerow(
            user
        )'''
with open("data.csv", "w") as file:
    writer=csv.writer(file)
    writer.writerows(
        users_data
    )
$ deactivate
$ python Py-WritingDataToACsvFile.py
user_name,user_address
user1,address1
user2,address2
user3,address3
Task:
Calendar.
Applications created in python using the tkinter module
Decision:
$ vim Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py
#Source: https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
from tkinter import *
import calendar
import datetime
root=Tk()
root.title('Calendar')
days=[]
now=datetime.datetime.now()
year=now.year
month=now.month
back_button=Button(root,text='<')
back_button.grid(row=0, column=0, sticky=NSEW)
next_button=Button(root,text='>')
next_button.grid(row=0, column=6, sticky=NSEW)
info_label=Label(root, text='0', width=1, height=1, font='Aria; 16 bold', fg='blue')
info_label.grid(row=0, column=1, columnspan=5, sticky=NSEW)
for n in range(7):
        lbl=Label(root, text=calendar.day_abbr[n], width=1, height=1, font='Arial 10 bold', fg='darkblue')
        lbl.grid(row=1, column=n, sticky=NSEW)
for row in range(6):
        for col in range(7):
                lbl=Label(root, text='0', width=4, height=2, font='Arial 16 bold')
                lbl.grid(row=row+2, column=col, sticky=NSEW)
                days.append(lbl)
root.mainloop()
$ vim Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py    
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py    
#Source: https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
from tkinter import *
import calendar
import datetime
def fill():
        info_label['text']=calendar.month_name[month]+', '+str(year)
        month_days=calendar.monthrange(year, month)[1]
        if month==1:
                back_month_days=calendar.monthrange(year-1, 12)[1]
        else:
                back_month_days=calendar.monthrange(year, month-1)[1]
        week_day=calendar.monthrange(year, month)[0]
        for n in range(month_days):
                days[n + week_day]['text']=n+1
                days[n + week_day]['fg']='black'
                if year == now.year and month == now.month and n == now.day:
                        days[week_day]['bg']='green'
                        days[n + week_day]['bg']='grey'
                else:
                        days[n + week_day]['bg']='gray'
root=Tk()
root.title('Calendar')
days=[]
now=datetime.datetime.now()
year=now.year
month=now.month
back_button=Button(root,text='<')
back_button.grid(row=0, column=0, sticky=NSEW)
next_button=Button(root,text='>')
next_button.grid(row=0, column=6, sticky=NSEW)
info_label=Label(root, text='0', width=1, height=1, font='Aria; 16 bold', fg='blue')
info_label.grid(row=0, column=1, columnspan=5, sticky=NSEW)
for n in range(7):
        lbl=Label(root, text=calendar.day_abbr[n], width=1, height=1, font='Arial 10 bold', fg='darkblue')
        lbl.grid(row=1, column=n, sticky=NSEW)
for row in range(6):
        for col in range(7):
                lbl=Label(root, text='0', width=4, height=2, font='Arial 16 bold')
                lbl.grid(row=row+2, column=col, sticky=NSEW)
                days.append(lbl)
fill()
root.mainloop()
$ vim Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py    
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py    
#Source: https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
from tkinter import *
import calendar
import datetime
def fill():
        info_label['text']=calendar.month_name[month]+', '+str(year)
        month_days=calendar.monthrange(year, month)[1]
        if month==1:
                back_month_days=calendar.monthrange(year-1, 12)[1]
        else:
                back_month_days=calendar.monthrange(year, month-1)[1]
        week_day=calendar.monthrange(year, month)[0]
        for n in range(month_days):
                days[n + week_day]['text']=n+1
                days[n + week_day]['fg']='black'
                if year == now.year and month == now.month and n == now.day:
                        days[week_day]['bg']='green'
                        days[n + week_day]['bg']='grey'
                else:
                        days[n + week_day]['bg']='gray'
        for n in range(week_day):
                days[week_day-n-1]['text']=back_month_days-n
                days[week_day-n-1]['fg']='gray'
                days[week_day-n-1]['bg']='#f3f3f3'
        for n in range(6*7-month_days-week_day):
                days[week_day+month_days+n]['text']=n+1
                days[week_day+month_days+n]['fg']='gray'
                days[week_day+month_days+n]['bg']='#f3f3f3'
root=Tk()
root.title('Calendar')
days=[]
now=datetime.datetime.now()
year=now.year
month=now.month
back_button=Button(root,text='<')
back_button.grid(row=0, column=0, sticky=NSEW)
next_button=Button(root,text='>')
next_button.grid(row=0, column=6, sticky=NSEW)
info_label=Label(root, text='0', width=1, height=1, font='Aria; 16 bold', fg='blue')
info_label.grid(row=0, column=1, columnspan=5, sticky=NSEW)
for n in range(7):
        lbl=Label(root, text=calendar.day_abbr[n], width=1, height=1, font='Arial 10 bold', fg='darkblue')
        lbl.grid(row=1, column=n, sticky=NSEW)
for row in range(6):
        for col in range(7):
                lbl=Label(root, text='0', width=4, height=2, font='Arial 16 bold')
                lbl.grid(row=row+2, column=col, sticky=NSEW)
                days.append(lbl)
fill()
root.mainloop()
$ vim Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py    
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-Calendar.py    
from tkinter import *
import calendar
import datetime
def back():
	global month, year
	month -= 1
	if month == 0:
		month=12
		year -= 1
	fill()
def next():
	global month, year
	month += 1
	if month == 13:
		month=11
		year += 1
	fill()
def fill():
	info_label['text']=calendar.month_name[month]+', '+str(year)
	month_days=calendar.monthrange(year, month)[1]
	if month==1:
		back_month_days=calendar.monthrange(year-1, 12)[1]
	else:
		back_month_days=calendar.monthrange(year, month-1)[1]
	week_day=calendar.monthrange(year, month)[0]
	for n in range(month_days):
		days[n + week_day]['text']=n+1
		days[n + week_day]['fg']='black'
		if year == now.year and month == now.month and n == now.day:
			days[week_day]['bg']='green'
			days[n + week_day]['bg']='grey'
		else:
			days[n + week_day]['bg']='gray'
	for n in range(week_day):
		days[week_day-n-1]['text']=back_month_days-n
		days[week_day-n-1]['fg']='gray'
		days[week_day-n-1]['bg']='#f3f3f3'
	for n in range(6*7-month_days-week_day):
		days[week_day+month_days+n]['text']=n+1
		days[week_day+month_days+n]['fg']='gray'
		days[week_day+month_days+n]['bg']='#f3f3f3'
root=Tk()
root.title('Calendar')
days=[]
now=datetime.datetime.now()
year=now.year
month=now.month
back_button=Button(root,text='<',command=back)
back_button.grid(row=0, column=0, sticky=NSEW)
next_button=Button(root,text='>',command=next)
next_button.grid(row=0, column=6, sticky=NSEW)
info_label=Label(root, text='0', width=1, height=1, font='Aria; 16 bold', fg='blue')
info_label.grid(row=0, column=1, columnspan=5, sticky=NSEW)
for n in range(7):
	lbl=Label(root, text=calendar.day_abbr[n], width=1, height=1, font='Arial 10 bold', fg='darkblue')
	lbl.grid(row=1, column=n, sticky=NSEW)
for row in range(6):	
	for col in range(7):
		lbl=Label(root, text='0', width=4, height=2, font='Arial 16 bold')
		lbl.grid(row=row+2, column=col, sticky=NSEW)
		days.append(lbl)
fill()
root.mainloop()
Source: 
https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
Task:
високосный год
Decision:
year=int(input("Укажите год: "))
if year%4==0:
    if year%100==0:
        if year%400==0:
            print("Это високосный год")
        else:
            print("Это не високосный год")
    else:
        print("Это високосный год")
else:
    print("Это не високосный год")
Task:
Погода
Decision:
#/usr/bin/python
# -*- encoding: utf-8 -*-
import pyowm
city=input('Какой город вас интересует? ')
owm = pyowm.OWM('566b41c32a6a99107ba96c215e9fafea')  # Yeu MUST provide a valid API key
# Have a pro subscription? Then use:
# owm = pyowm.OWM(API_key='your-API-key', subscription_type='pro')
# Search for current weather in London (Great Britain)
observation = owm.weather_at_place('city')
w = observation.get_weather()
temperature=w.get_temperature('celsius')['temp']
print("В городе" + city  +" Сейчас температура: " + str(temperature))                      # <Weather - reference time=2013-12-18 09:20,
                              # status=Clouds>
# Weather details
#w.get_wind()                  # {'speed': 4.6, 'deg': 330}
#w.get_humidity()              # 87
#w.get_temperature('celsius')  # {'temp_max': 10.5, 'temp': 9.7, 'temp_min': 9.0}
# Search current weather observations in the surroundings of
# lat=22.57W, lon=43.12S (Rio de Janeiro, BR)
#observation_list = owm.weather_around_coords(-2257, -43.12)
TasK:
Paint
Decision:
from kivy.app import App #1
from kivy.uix.widget import Widget #1
from kivy.graphics import (Color, Ellipse, Rectangle, Line) #3 чтобы начать что то рисовать нужны граф инструкци
#google -kivy graphics
from random import random
from kivy.uix.button import Button #23
from kivy.core.window import Window#34 чтоб узнать ширину и высоту окна
class PainterWidget(Widget): #2
    #4 pass #2
    ''' #12 Можем удалить
    def __init__(self, **kwargs):#5 теперь можем начать рисовать, сначала сделаемм инициализацию
        super(PainterWidget, self).__init__(**kwargs) #5

        with self.canvas:#6 после этого нужно обратиться к self canvas
            Color(0,1,0,1)#7 можно уже начать перечислять нужные граф инструкции, Цвет
            #9 Ellipse(pos=(100,100), size=(50,50))#7 адрессовать круг, если запусти увидим зеленый круг
            #9 Line(points=(100, 100, 150, 200, 200, 100), close=True, width=5)#7 Нарисуется треугольник
            self.line=Line(points=(), width=10, joint='miter', cap='square')#8 Можно сделать по другому. создадим линию
    '''
    def on_touch_down(self, touch):#10 Сделаем еще событие, которая вызывается тогда когда нажимается мышь или как при андроеде. touch содержит инфу о клике.
        #12 self.line.points += (touch.x, touch.y)#11 линию которую мы создали в #10, дополняемя точками, которым мы кликаем. на окошке мы увидим черный экран, и когда нажмем один раз и второй раз в другом есте пояится линия
        with self.canvas:#13 нарисуем круг зеленого цвет  с радиусом 30
            Color(random(),random(),random(),1)#13
            rad=30#13
            Ellipse(pos=(touch.x-rad/2, touch.y-rad/2), size=(rad,rad))#13 -rad/2 это чтоб рисовался по центру мыши
            #13 на экране при клике на любое место появится точки
            touch.ud['line']=Line(points=(touch.x, touch.y), width=15)#15 Теперь уже хотим нарисовать. с помощью ud можем передавать определенную инфу меж событиями on_touch_move и on_touch_down. И создадим ячейку line            
    def on_touch_move(self, touch):#14 добавим еще одно событие, 
        #16 pass
        touch.ud['line'].points += (touch.x, touch.y)#17 на эране теперь уже что то рисуем
class PaintApp(App): #1
    def build(self): #1
        #pass #1
        #19 return PainterWidget() #2
        #18 Хотим теперь чтоб наши данные записывались
        parent=Widget() #20
        #27 parent.add_widget(PainterWidget()) #21
        self.painter=PainterWidget()#28
        parent.add_widget(self.painter)#29
        parent.add_widget(Button(text='Ochistit', on_press=self.clear_canvas, size=(100, 50))) #24
        parent.add_widget(Button(text='Save', on_press=self.save, size=(100, 50), pos=(100,0))) #29
        parent.add_widget(Button(text='Screen', on_press=self.screen, size=(100, 50), pos=(200,0))) #33        
        return parent #22
    def clear_canvas(self, instance):#25 Объявим эту функцию clear_canvas
        #27 pass #26 на окошке появится кнопка
        self.painter.canvas.clear()#30 очистит
    def save(self, instance):#31 Объявим эту функцию save
        self.painter.size=(Window.size[0], Window.size[1])#33 изменим размер виджета, так как сохраняет только маленькую часть. 0 -по оси х, 1 - по оси у
        self.painter.export_to_png('image.png') #32 идет сохранение
    def screen(self, instance):#35
        Window.screenshot('screen.png')
if __name__ == '__main__': #1
    PaintApp().run() #1
Task:
Разработка текстового редактора
Decision:
$ vim Py-ApplicationsCreatedInPythonUsingTheTkinterModule-TextEditor.py    
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-TextEditor.py
#Source: https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
from tkinter import *
root=Tk()
root.title('Text editor')
root.geometry('600x700')
#root.iconbitmap('notepad.ico')
f_text=Frame(root)
f_text.pack(fill=BOTH, expand=1)
text_fild=Text(f_text,
        bg='black',
        fg='lime',
        padx=10,
        pady=10,
        wrap=WORD,
        insertbackground='blue',
        selectbackground='white',
        spacing3=10,
        width=30
        )
text_fild.pack(expand=1, fill=BOTH, side=LEFT)
scroll=Scrollbar(f_text,command=text_fild.yview)
scroll.pack(side=LEFT, fill=Y)
text_fild.config(yscrollcommand=scroll.set)
root.mainloop()
$ vim Py-ApplicationsCreatedInPythonUsingTheTkinterModule-TextEditor.py    
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-TextEditor.py
#Source: https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
from tkinter import *
root=Tk()
root.title('Text editor')
root.geometry('600x700')
#root.iconbitmap('notepad.ico')
main_menu=Menu(root)
#File
file_menu=Menu(main_menu, tearoff=0)
file_menu.add_command(label='Open')
file_menu.add_command(label='Save')
file_menu.add_separator()
file_menu.add_command(label='Close')
#View
view_menu=Menu(main_menu, tearoff=0)
view_menu_sub=Menu(view_menu, tearoff=0)
font_menu_sub=Menu(view_menu, tearoff=0)
view_menu_sub.add_command(label='Dark')
view_menu_sub.add_command(label='Light')
view_menu.add_cascade(label='Theme', menu=view_menu_sub)
font_menu_sub.add_command(label='Arial')
font_menu_sub.add_command(label='Comic Sans MS')
font_menu_sub.add_command(label='Times New Rowan')
view_menu.add_cascade(label='font',menu=font_menu_sub)
root.config(menu=view_menu)
#Add lists menu
main_menu.add_cascade(label='File', menu=file_menu)
main_menu.add_cascade(label='View', menu=view_menu)
root.config(menu=main_menu)
f_text=Frame(root)
f_text.pack(fill=BOTH, expand=1)
text_fild=Text(f_text,
        bg='black',
        fg='lime',
        padx=10,
        pady=10,
        wrap=WORD,
        insertbackground='blue',
        selectbackground='white',
        spacing3=10,
        width=30
        )
text_fild.pack(expand=1, fill=BOTH, side=LEFT)
scroll=Scrollbar(f_text,command=text_fild.yview)
scroll.pack(side=LEFT, fill=Y)
text_fild.config(yscrollcommand=scroll.set)
root.mainloop()
Decision:
$ cat Py-ApplicationsCreatedInPythonUsingTheTkinterModule-TextEditor.py
#Source: https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
from tkinter import *
from tkinter import messagebox
from tkinter import filedialog
def chenge_theme(theme):
    text_fild['bg']=view_colors[theme]['text_bg']
    text_fild['fg']=view_colors[theme]['text_fg']
    text_fild['insertbackground']=view_colors[theme]['cursor']
    text_fild['selectbackground']=view_colors[theme]['select_bg']
def chenge_fonts(fontss):
    text_fild['font']=fonts[fontss]['font']
def notepad_exit():
    answer=messagebox.askokcancel('Quit','Are you sure?')
    if answer:
        root.destroy()
def open_file():
    file_path=filedialog.askopenfilename(title='choice file', filetypes=(('Text docs (*.txt)','*.txt'),('All files', '*.*')))
    if file_path:
        text_fild.delete('1.0', END)
        text_fild.insert('1.0', open(file_path, encoding='utf-8').read())
def save_file():
    file_path=filedialog.asksaveasfilename(filetypes=(('Text docs (*.txt)','*.txt'),('All files', '*.*')))
    f=open(file_path, 'w', encoding='utf-8')
    text=text_fild.get('1.0', END)
    f.write(text)
    f.close()
root=Tk()
root.title('Text editor')
root.geometry('600x700')
#root.iconbitmap('notepad.ico')
main_menu=Menu(root)
#File
file_menu=Menu(main_menu, tearoff=0)
file_menu.add_command(label='Open', command=open_file)
file_menu.add_command(label='Save', command=save_file)
file_menu.add_separator()
file_menu.add_command(label='Close', command=notepad_exit)
#View
view_menu=Menu(main_menu, tearoff=0)
view_menu_sub=Menu(view_menu, tearoff=0)
font_menu_sub=Menu(view_menu, tearoff=0)
view_menu_sub.add_command(label='Dark', command=lambda: chenge_theme('dark'))
view_menu_sub.add_command(label='Light', command=lambda: chenge_theme('light'))
view_menu.add_cascade(label='Theme', menu=view_menu_sub)
font_menu_sub.add_command(label='Arial', command=lambda: chenge_fonts('Arial'))
font_menu_sub.add_command(label='Comic Sans MS', command=lambda: chenge_fonts('CSMS'))
font_menu_sub.add_command(label='Times New Rowan', command=lambda: chenge_fonts('TNR'))
view_menu.add_cascade(label='font',menu=font_menu_sub)
root.config(menu=view_menu)
#Add lists menu
main_menu.add_cascade(label='File', menu=file_menu)
main_menu.add_cascade(label='View', menu=view_menu)
root.config(menu=main_menu)
f_text=Frame(root)
f_text.pack(fill=BOTH, expand=1)
text_fild=Text(f_text,
        bg='black',
        fg='lime',
        padx=10,
        pady=10,
        wrap=WORD,
        insertbackground='blue',
        selectbackground='white',
        spacing3=10,
        width=30,
        font='Arial 14 bold'
        )
view_colors={'dark':{'text_bg':'black',
            'text_fg':'lime',
            'cursor':'blue',
            'select_bg':'white'},
        'light':{
            'text_bg':'white',
            'text_fg':'black',
            'cursor':'blue',
            'select_bg':'black'}}
fonts={
        'Arial':{
                'font':'Arial 14 bold'
        },
        'CSMS':{
                'font':('Comic Sans MS', 14, 'bold')
        },
        'TNR':{
                'font':('Times New Roman', 14, 'bold')
        }
}
text_fild.pack(expand=1, fill=BOTH, side=LEFT)
scroll=Scrollbar(f_text,command=text_fild.yview)
scroll.pack(side=LEFT, fill=Y)
text_fild.config(yscrollcommand=scroll.set)
root.mainloop()
Source: 
https://www.youtube.com/playlist?list=PL9aGGxgLOVw44btcB1CM6j_jhrl7L95aH
Task:
Работаем с ПДФ файлами. Выведем только первые 5 страниц
Decision:
import fitz # Фитз входит в состав библиотеки PyMuPDF
spisok=list(range(5)) # Список с номерами первых 5 страниц
docu=fitz.open("pdf_file.pdf")
docu.select(spisok) # Удаляются все, кроме 5 страниц
docu.save("pdf_file2.pdf", garbage=3)
docu.close()
"""
import  fitz
stroka_1="ABCD"; stroka_2="EFGH"; stroka_3="IJKL"
new_docu=fitz.open()
new_docu.insertPage(text=stroka_1, fontsize=11)
new_docu.insertPage(text=stroka_2, fontsize=20)
new_docu.insertPage(text=None, fontsize=20)
new_docu.insertPage(text=stroka_3, fontsize=20)
new_docu.save("NewFile.pdf", garbage=3)
new_docu_2=fitz.open("NewFile.pdf")
spisok2=list(range(new_docu_2.pageCount))
for page_number in spisok2:
    if not new_docu.getPageText(page_number):
        spisok2.remove(page_number)
new_docu_2.select(spisok2)
new_docu_2.save("NewFileResult.pdf", garbage=3)
new_docu.close()
new_docu_2.close()
"""
Task:
How to Build A Machine Learning Web App with Python
From scratch, we will deploy a linear regression model using Flask, a Python framework for developing web applications
Decision:
$ python3 -m venv Py-FrankAndrade-WebAppMO-Env
$ mkdir Py-FrankAndrade-WebAppMO-Project
$ source Py-FrankAndrade-WebAppMO-Env/bin/activate
$ pip list
Package    Version
---------- -------
pip        22.0.2
setuptools 59.6.0
$ pip install flask
$ pip list
Package      Version
------------ -------
click        8.1.3
Flask        2.1.2
itsdangerous 2.1.2
Jinja2       3.1.2
MarkupSafe   2.1.1
pip          22.0.2
setuptools   59.6.0
Werkzeug     2.1.2
$ vim Py-FrankAndrade-WebAppMO-Project/app.py
$ cat Py-FrankAndrade-WebAppMO-Project/app.py
from flask import Flask
app = Flask(__name__)
@app.route("/")
def hello_world():
    return "<p>Hello, World!</p>"
if __name__ == "__main__":
    app.run()
$ cd Py-FrankAndrade-WebAppMO-Project/
$ python app.py
 * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
Decision:
Заходим в браузер и пишем адрес: http://127.0.0.1:5000. должно появиться приветсвие
Decision:
$ pip install sklearn
$ pip install pandas
$ cd templates/
/templates$ vim index.html
rade-WebAppMO/Py-FrankAndrade-WebAppMO-Project/templates$ cat index.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title> Web App MO </title>
</head>
<body>
    <h1>My first WebSite</h1>
</body>
</html>
$ cat model.py
from sklearn import linear_model
import pandas as pd
import pickle
df = pd.read_csv('prices.csv')
y = df['Value'] # dependent variable
X = df[['Rooms', 'Distance']] # independent variable
lm = linear_model.LinearRegression()
lm.fit(X, y) # fitting the model
pickle.dump(lm, open('model.pkl','wb')) # save the model
print(lm.predict([[15, 61]]))  # format of input
print(f'score: {lm.score(X, y)}')
$ python app.py
/home/user/Py-FrankAndrade-WebAppMO/Py-FrankAndrade-WebAppMO-Env/lib/python3.10/site-packages/sklearn/base.py:329: UserWarning: Trying to unpickle estimator LinearRegression from version 1.0.2 when using version 1.1.1. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
  warnings.warn(
 * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
Decision:
Заходим в браузер и пишем адрес: http://127.0.0.1:5000.
Decision:
$ vim templates/index.html
$ cat templates/index.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title> Web App MO </title>
    <!-- CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Navbar</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#">Link</a>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Dropdown
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                <li><a class="dropdown-item" href="#">Action</a></li>
                <li><a class="dropdown-item" href="#">Another action</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#">Something else here</a></li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link disabled">Disabled</a>
            </li>
          </ul>
          <form class="d-flex">
            <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
            <button class="btn btn-outline-success" type="submit">Search</button>
          </form>
        </div>
      </div>
    </nav>    
</head>
<body>
    <!--<h1>My first WebSite</h1>-->
</body>
</html>
$ python app.py
/home/user/Py-FrankAndrade-WebAppMO/Py-FrankAndrade-WebAppMO-Env/lib/python3.10/site-packages/sklearn/base.py:329: UserWarning: Trying to unpickle estimator LinearRegression from version 1.0.2 when using version 1.1.1. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
  warnings.warn(
 * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
Decision:
Заходим в браузер и пишем адрес: http://127.0.0.1:5000.
Decision:
$ vim templates/index.html
$ cat templates/index.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title> Web App MO </title>
    <!-- CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Navbar</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#">Link</a>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Dropdown
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                <li><a class="dropdown-item" href="#">Action</a></li>
                <li><a class="dropdown-item" href="#">Another action</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#">Something else here</a></li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link disabled">Disabled</a>
            </li>
          </ul>
          <form class="d-flex">
            <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
            <button class="btn btn-outline-success" type="submit">Search</button>
          </form>
        </div>
      </div>
    </nav>    
</head>
<body>
    <!--<h1>My first WebSite</h1>-->
    <div class="login">
        <h2>Price Prediction</h2>
            <p>Introduce the number of rooms and distance:</p>
            <form action="{{url_for('predict')}}" method="post">
                <input type="text" name="rooms" placeholder="Rooms" required="required">
                <input type="text" name="distance" placeholder="Distance" required="required">
                <button type="submit" class="btn btn-primary btn-block btn-large"> Predict Value!</button>
            </form>
            <br>
            <br>    
        <b>{{prediction_text}}</b>
    </div>
</body>
</html>
$ vim app.py
$ cat app.py
from flask import Flask, render_template, request
import pickle
app = Flask(__name__)
model=pickle.load(open('model.pkl', 'rb'))
@app.route("/")
#def hello_world():
def hello():
    #return "<p>Hello, World!</p>"
    return render_template('index.html')
@app.route("/predict", methods=['POST'])
def predict():
    rooms = int(request.form['rooms'])
    distance = int(request.form['distance'])
    prediction = model.predict([[rooms, distance]])
    output = round(prediction[0], 2)
    return render_template('index.html', prediction_text=f'A house with {rooms} rooms per dwelling and located {distance} km to employment centers has a value of ${output}K')
if __name__ == "__main__":
    app.run()
$ python app.py
/home/user/Py-FrankAndrade-WebAppMO/Py-FrankAndrade-WebAppMO-Env/lib/python3.10/site-packages/sklearn/base.py:329: UserWarning: Trying to unpickle estimator LinearRegression from version 1.0.2 when using version 1.1.1. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
  warnings.warn(
 * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
Decision:
Заходим в браузер и пишем адрес: http://127.0.0.1:5000.
Source:
https://www.youtube.com/c/FrankAndrade5/videos
Task:
Режим засыпания.
Calling sleep() via time.sleep()
Decision:
$ python3 -m venv Py-Env
$ source Py-Env/bin/activate
$ ls
Py-Env
$ vim Py-SLeep.py
$ python3 Py-SLeep.py
$ cat Py-SLeep.py
#Вызов sleep() через time.sleep()
import time
time.sleep(3) # Сон в 3 секунды
$ python3 -m timeit -n 3 "import time; time.sleep(3)"
3 loops, best of 5: 3 sec per loop
Task:
Системному администратору всегда нужно быть в курсе, если какой-то из сайтов упал. Вы бы хотели иметь возможность проверить код состояния сайта регулярно, но запрашивать веб сервер постоянно нельзя, ведь это сильно повлияет на производительность. В Python одним из простых способов совершить такую проверку является использование системного вызова sleep()
Decision:
$ vim Py-SLeep1.py
$ cat Py-SLeep1.py
import time
import urllib.request
import urllib.error
def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Отправка admin / log
            print(f'HTTPError: {e.code} для {url}')
        except urllib.error.URLError as e:
            # Отправка admin / log
            print(f'URLError: {e.code} для {url}')
        else:
            # Сайт поднят
            print(f'{url} поднят')
        time.sleep(60)
if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)
$ pip install requests
$ python3 Py-SLeep1.py
HTTPError: 404 для http://www.google.com/py
$ vim Py-SLeep1.py
$ cat Py-SLeep1.py
import time
import urllib.request
import urllib.error
def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Отправка admin / log
            print(f'HTTPError: {e.code} для {url}')
        except urllib.error.URLError as e:
            # Отправка admin / log
            print(f'URLError: {e.code} для {url}')
        else:
            # Сайт поднят
            print(f'{url} поднят')
        time.sleep(60)
if __name__ == '__main__':
    url = 'http://www.google.com'
    uptime_bot(url)
$ python3 Py-SLeep1.py
http://www.google.com поднят
Task:
Вызов sleep() с декораторами
Decision:
$ vim Py-SLeep2.py
$ cat Py-SLeep2.py
import time
import urllib.request
import urllib.error
def sleep(timeout, retry=3):
    def the_real_decorator(function):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < retry:
                try:
                    value = function(*args, **kwargs)
                    if value is None:
                        return
                except:
                    print(f'Сон на {timeout} секунд')
                    time.sleep(timeout)
                    retries += 1
        return wrapper
    return the_real_decorator
@sleep(3)
def uptime_bot(url):
    try:
        conn = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        # Отправка admin / log
        print(f'HTTPError: {e.code} для {url}')
        # Повторное поднятие ошибки исключения для декоратора
        raise urllib.error.HTTPError
    except urllib.error.URLError as e:
        # Отправка admin / log
        print(f'URLError: {e.code} для {url}')
        # Повторное поднятие ошибки исключения для декоратора
        raise urllib.error.URLError
    else:
        # Сайт поднят
        print(f'{url} поднят')
if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)
$ python3 Py-SLeep2.py
HTTPError: 404 для http://www.google.com/py
Сон на 3 секунд
HTTPError: 404 для http://www.google.com/py
Сон на 3 секунд
HTTPError: 404 для http://www.google.com/py
Сон на 3 секунд
Task:
Использование time.sleep() в threading
Decision:
$ vim Py-SLeep3.py
$ cat Py-SLeep3.py
import logging
import threading
import time
def worker(arg):
    while not arg["stop"]:
        logging.debug("рабочий поток вносится")
        time.sleep(1)
def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    info = {"stop": False}
    thread = threading.Thread(target=worker, args=(info,))
    thread_two = threading.Thread(target=worker, args=(info,))
    thread.start()
    thread_two.start()
    while True:
        try:
            logging.debug("Добавление из главного потока")
            time.sleep(0.75)
        except KeyboardInterrupt:
            info["stop"] = True
            logging.debug('Остановка')
            break
    thread.join()
    thread_two.join()
if __name__ == "__main__":
    main()
$ python3 Py-SLeep3.py
     2 Thread-1 (worker) рабочий поток вносится
     3 Thread-2 (worker) рабочий поток вносится
     3 MainThread Добавление из главного потока
   754 MainThread Добавление из главного потока
  1004 Thread-1 (worker) рабочий поток вносится
  1004 Thread-2 (worker) рабочий поток вносится
  1505 MainThread Добавление из главного потока
  2005 Thread-1 (worker) рабочий поток вносится
  2006 Thread-2 (worker) рабочий поток вносится
  2256 MainThread Добавление из главного потока
  3007 Thread-1 (worker) рабочий поток вносится
  3007 MainThread Добавление из главного потока
  3007 Thread-2 (worker) рабочий поток вносится
  3759 MainThread Добавление из главного потока
  4009 Thread-1 (worker) рабочий поток вносится
  4009 Thread-2 (worker) рабочий поток вносится
  4510 MainThread Добавление из главного потока
  5010 Thread-1 (worker) рабочий поток вносится
  5010 Thread-2 (worker) рабочий поток вносится
  5261 MainThread Добавление из главного потока
^C  5880 MainThread Остановка
Task:
Вызов sleep() с Async IO
Decision:
$ vim Py-SLeep4.py
$ cat Py-SLeep4.py
#Вызов sleep() с Async IO
import asyncio
async def main():
    print('Hello ...')
    await asyncio.sleep(1)
    print('... World!')
# Python 3.7+
asyncio.run(main())
$ python3 Py-SLeep4.py
Hello ...
... World!
$ vim Py-SLeep5.py
$ cat Py-SLeep5.py
import asyncio
import time
async def output(sleep, text):
    await asyncio.sleep(sleep)
    print(text)
async def main():
    print(f"Started: {time.strftime('%X')}")
    await output(1, 'First')
    await output(2, 'Second')
    await output(3, 'Third')
    print(f"Ended: {time.strftime('%X')}")
# Python 3.7+
asyncio.run(main())
$ python3 Py-SLeep5.py
Started: 11:41:57
First
Second
Third
Ended: 11:42:03
Decision:
$ vim Py-SLeep6.py
$ cat Py-SLeep6.py
import asyncio
import time
async def output(text, sleep):
    while sleep > 0:
        await asyncio.sleep(1)
        print(f'{text} counter: {sleep} seconds')
        sleep -= 1
async def main():
    task_1 = asyncio.create_task(output('First', 1))
    task_2 = asyncio.create_task(output('Second', 2))
    task_3 = asyncio.create_task(output('Third', 3))
    print(f"Started: {time.strftime('%X')}")
    await task_1
    await task_2
    await task_3
    print(f"Ended: {time.strftime('%X')}")
if __name__ == '__main__':
    asyncio.run(main())
$ python3 Py-SLeep6.py
Started: 11:43:16
First counter: 1 seconds
Second counter: 2 seconds
Third counter: 3 seconds
Second counter: 1 seconds
Third counter: 2 seconds
Third counter: 1 seconds
Ended: 11:43:19
Task:
Метод after() — Погружение в сон для Tkinter
Decision:
$ vim Py-SLeep7.py
$ cat Py-SLeep7.py
import tkinter
import time
class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        b = tkinter.Button(text="click me", command=self.delayed)
        b.pack()
    def delayed(self):
        time.sleep(3)
if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()
Task:
Для должного погружения tkinter в сон потребуется использовать after()
Decision:
$ vim Py-SLeep8.py
$ cat Py-SLeep8.py
import tkinter
class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        self.root.after(3000, self.delayed)
    def delayed(self):
        print('Я задержался')
if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()
$ python3 Py-SLeep8.py
Я задержался
Task:
Обработка логов
Decision:
$ mkdir Py-Logging
$ cd Py-Logging
$ python3 -m venv Py-Env
$ source Py-Env/bin/activate
$ vim Py-Logging.py
$ cat Py-Logging.py
import logging
logging.basicConfig(
    level=logging.DEBUG,
    filename="mylog.log",
    format="%(asctime)s - %(module)s - %(levelname)s - %(funcName)s: %(lineno)d - %(message)s",
    datefmt='%H:%M:%S',
    )
logging.info('Hello')
$ python Py-Logging.py
$ ls
mylog.log  Py-Env  Py-Logging.py
$ cat mylog.log
12:35:11 - Py-Logging - INFO - <module>: 8 - Hello
$ deactivate
Task:
Make a program for viewing images
Decision:
$ mkdir Py-ViewingImages
$ cd Py-ViewingImages
$ python3 -m venv Py-Env
$ source Py-Env/bin/activate
$ vim Py-ViewingImages.py
$ cat Py-ViewingImages.py
import tkinter as tk
from PIL import Image, ImageTk
from resizeimage import resizeimage
win=tk.Tk()
win.title("Image Viewer")
win.geometry("300x300")
path=r'/home/user/Документы/.Git/Py/Py-ViewingImages/img/test.jpg'
resized_image=resizeimage.resize_cover(Image.open(path), [300, 300])
render_pic=ImageTk.PhotoImage(resized_image)
img.pack()
win.mainloop()
$ sudo apt-get install python3-tk
$ pip install Pillow
$ pip install python-resize-image
$ vim Py-ViewingImages.py
$ cat Py-ViewingImages.py
import tkinter as tk
from PIL import Image, ImageTk
from resizeimage import resizeimage
win=tk.Tk()
win.title("Image Viewer")
win.geometry("300x300")
path=r'/home/user/Документы/.Git/Py/Py-ViewingImages/img/test.jpg'
resized_image=resizeimage.resize_cover(Image.open(path), [300, 300])
render_pic=ImageTk.PhotoImage(resized_image)
img=tk.Label(win,image=render_pic)
img.pack()
win.mainloop()
$ python Py-ViewingImages.py
$ deactivate
Task:
Вам дан английский текст. Закодируйте его с помощью азбуки Морзе. Каждая буква заменяется на последовательность точек и тире. В качестве тире используйте обычный дефис «-», а в качестве точки — точку «.». Например, буква «g» превратится в трёхсимвольную строку «--.». Ниже в переменной morze для вашего удобства хранится словарь соответствия английских букв коду Морзе. Входные данные Весь текст записан в единственной строке. Текст состоит из английских букв и пробелов, других символов в тексте нет. В тексте не может быть двух или более пробелов подряд. Выходные данные Выведите каждое слово исходного текста, закодированное азбукой Морзе, на отдельной строке. Количество строк в ответе должно совпадать с количеством слов в исходном тексте. Между закодированными буквами ставится ровно один пробел. Например, слово «Help» превратится в «.... . .-.. .--.». Обратите внимание, что строчные и заглавные буквы кодируются одинаково.
Decision:
$ cat test.py            
morze = {'a': '•—', 'b': '—•••', 'c': '—•—•', 'd': '—••',
        'e': '•', 'f': '••—•', 'g': '——•', 'h': '••••',
        'i': '••', 'j': '•———', 'k': '—•—', 'l': '•—••',
        'm': '——', 'n': '—•', 'o': '———', 'p': '•——•',
        'q': '——•—', 'r': '•—•', 's': '•••', 't': '—',
        'u': '••—', 'v': '•••—', 'w': '•——', 'x': '—••—',
        'y': '—•——', 'z': '——••'}
text= input()
text= text.lower()
i=0
for key in text:
    i=i+1
    if key == ' ': 
        print('') 
        i=0
    else:
        if i>=2: 
                print (' ', end='')
        val = str(morze[key])
        print (val, end='')  
$ python3 test.py
I want cheeseburger
••
•—— •— —• —
—•—• •••• • • ••• • —••• ••— •—• ——• • •—• 
Task:
Мне нужно написать программу, которая считывает возраст человека. Программа сначала запрашивает год рождения.
Decision:
$ cat Cpp-AgeDetermination.cpp
#include <iostream>
using namespace std;
int age(int current_date, int current_month, int current_year, int birth_date, int birth_month, int birth_year)
{
  //если дата рождения больше текущей даты рождения тогда не считайте в этом месяце и добавьте 30 к дате так как вычесть дату и получить оставшиеся дни
  int month[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  if (birth_date > current_date)
  {
    current_month = current_month - 1;
    current_date = current_date + month[birth_month-1];
  }
  //если месяц рождения превышает текущий месяц, то  Не считайте в этом году и добавьте 12 к месяц, чтобы мы могли вычесть и выяснить различия
  if (birth_month > current_month)
  {
    current_year = current_year - 1;
        current_month = current_month + 12;
  }
    // вычислить дату, месяц, год
    int calculated_date = current_date - birth_date;
    int calculated_month = current_month - birth_month;
    int calculated_year = current_year - birth_year;
  // печать нынешнего возраста
    cout<<"Present Age:"<<endl;
    cout<<"Years: "<<calculated_year<<" Months: "<<calculated_month<<" Days: "<<calculated_date<<endl;
  return 0;
}
int main()
{
  int current_date, current_month, current_year, birth_date, birth_month, birth_year;
  //код пользователя
  cout<<"Today:"<<endl;
  cout<<"DD: ";
  cin>>current_date;
  cout<<"MM: ";
  cin>>current_month;
  cout<<"YYYY: ";
  cin>>current_year;
  //рождение дд // мм // гггг
  cout<<"You'r Birthday:"<<endl;
  cout<<"DD: ";
  cin>>birth_date;
    cout<<"MM: ";
  cin>>birth_month;
    cout<<"YYYY:";
  cin>>birth_year;
  age(current_date, current_month, current_year, birth_date, birth_month, birth_year);
  system("pause");
  return 0;
}
$ cat Py-AgeDetermination.py
def age(current_date, current_month, current_year, birth_date, birth_month, birth_year):
    #если дата рождения больше текущей даты рождения тогда не считайте в этом месяце и добавьте 30 к дате так как вычесть дату и получить оставшиеся дни
    month =[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if (birth_date > current_date):
        current_month = current_month - 1
        current_date = current_date + month[birth_month-1]
    #если месяц рождения превышает текущий месяц, то Не считайте в этом году и добавьте 12 к месяц, чтобы мы могли вычесть и выяснить различия
    if (birth_month > current_month):
        current_year = current_year - 1;
        current_month = current_month + 12;
    # вычислить дату, месяц, год
    calculated_date = current_date - birth_date;
    calculated_month = current_month - birth_month;
    calculated_year = current_year - birth_year;
    # печать нынешнего возраста
    print("Present Age:")
    print("Years:", calculated_year, "Months:", calculated_month, "Days:", calculated_date)
print("Today:")
# код пользователя
current_date = int(input("DD: "))
current_month = int(input("MM: "))
current_year = int(input("YYYY: "))
# рождение дд // мм // гггг
print("You'r Birthday:")
birth_date = int(input("DD: "))
birth_month = int(input("MM: "))
birth_year = int(input("YYYY: "))
age(current_date, current_month, current_year, birth_date, birth_month, birth_year)
$ python3 Py-AgeDetermination.py
Today:
DD: 18
MM: 07
YYYY: 2022
You'r Birthday:
DD: 23
MM: 09
YYYY: 1992
Present Age:
Years: 29 Months: 9 Days: 25
$ g++ Cpp-AgeDetermination.cpp -o output
$ ./output
Today:
DD: 18
MM: 07
YYYY: 2022
You'r Birthday:
DD: 23
MM: 09
YYYY:1992
Present Age:
Years: 29 Months: 9 Days: 25
Task:
Создайте конвертер валют, который получает данные из национального банка с помощью json и выводит данные о стоимости рубля к доллару, евро и юаню. Запустите программу через терминал.
Decision:
$ cat Cpp-CurrencyConverter.cpp
#include <iostream>
using namespace std;
int main()
{
  float dollar, euro, yuan;
  cout<<"current dollar data: ";
  cin>>dollar;
        cout<<"current euro data: ";
  cin>>euro;
        cout<<"current yuan data: ";
  cin>>yuan;
  //cout<<dollar<<" "<<euro<<" "<<yuan<<" "<<endl;
  cout<<"1) Convert to dollars, Euros, yuan"<<endl<<"2) Transfer from dollars, Euros, yuan"<<endl<<"Choose your actions: ";
  int choise;
  cin>>choise;
  //cout<<choise; 
  if (choise==1){
    float ruble, resultDollar, resultEuro, resultYuan;
    cout<<"Enter the number of rubles: ";
    cin>>ruble;
    resultDollar=ruble/dollar;
    resultEuro=ruble/euro;
    resultYuan=ruble/yuan;
    cout<<"The result of your transfer = "<<resultDollar<<endl<<"The result of your transfer = "<<resultEuro<<endl<<"The result of your transfer = "<<resultYuan<<endl;
  } else if (choise==2) {
    float d, e, y, resultDollar, resultEuro, resultYuan;
    cout<<"Enter the number of dollars: ";
    cin>>d;
    cout<<"Enter the number of euroes: ";
    cin>>e;
    cout<<"Enter the number of yuans: ";
    cin>>y;
    resultDollar=d*dollar;
    resultEuro=e*euro;
    resultYuan=y*yuan;
    cout<<"The result of your transfer = "<<resultDollar<<endl<<"The result of your transfer = "<<resultEuro<<endl<<"The result of your transfer = "<<resultYuan<<endl;
  } else {
    cout<<"Error! Enter only 1 or 2: "<<endl;
    exit(0);
  }
  //system("pause");
  return 0;
}
$ cat Py-CurrencyConverter.py 
from pprint import pprint
import requests
data = requests.get('https://www.cbr-xml-daily.ru/daily_json.js').json()
dictionaryU=data['Valute']['USD']
dictionaryE=data['Valute']['EUR']
dictionaryC=data['Valute']['CNY']
'''
lists=[dictionaryU, dictionaryE, dictionaryC]
for index in lists:
  print(index)
'''
'''
print(dictionaryU['Value'],dictionaryU['Name'])
print(dictionaryE['Value'],dictionaryE['Name'])
print(dictionaryC['Value'],dictionaryC['Name'])
'''
'''
dollar=float(input("Enter the dollar rate: "))
euro=float(input("Enter the euro exchange rate: "))
yuan=float(input("Enter the yuan exchange rate: "))
'''
dollar=dictionaryU['Value']
euro=dictionaryE['Value']
yuan=dictionaryC['Value']
print("Dollar exchange rate: ",dollar)
print("Euro exchange rate: ",euro)
print("Yuan exchange rate: ",yuan)
print("1) Convert to dollars, Euros, yuan\n2) Transfer from dollars, Euros, yuan\n")
choise=int(input("Choose your actions:\n"))
if choise==1:
  ruble=float(input("Enter the number of rubles: "))
  resultDollar=ruble/dollar
  resultEuro=ruble/euro
  resultYuan=ruble/yuan
  print("The result of your transfer = ", '{:.2f}'.format(resultDollar))
  print("The result of your transfer = ", '{:.2f}'.format(resultEuro))
  print("The result of your transfer = ", '{:.2f}'.format(resultYuan))
elif choise==2:
  d=float(input("Enter the number of dollars: "))
  e=float(input("Enter the number of euroes: "))  
  y=float(input("Enter the number of yuans: "))
  resultDollar=d*dollar
  resultEuro=e*euro
  resultYuan=y*yuan
  print("The result of your transfer = ", '{:.2f}'.format(resultDollar))
  print("The result of your transfer = ", '{:.2f}'.format(resultEuro))
  print("The result of your transfer = ", '{:.2f}'.format(resultYuan))
else:
  print("Error! Enter only 1 or 2")
  exit(0)
$ python3 Py-CurrencyConverter.py
Dollar exchange rate:  61.3101
Euro exchange rate:  62.5695
Yuan exchange rate:  92.1636
1) Convert to dollars, Euros, yuan
2) Transfer from dollars, Euros, yuan
Choose your actions:
1
Enter the number of rubles: 500
The result of your transfer =  8.16
The result of your transfer =  7.99
The result of your transfer =  5.43
$ python3 Py-CurrencyConverter.py
Dollar exchange rate:  61.3101
Euro exchange rate:  62.5695
Yuan exchange rate:  92.1636
1) Convert to dollars, Euros, yuan
2) Transfer from dollars, Euros, yuan
Choose your actions:
2
Enter the number of dollars: 1000
Enter the number of euroes: 900
Enter the number of yuans: 100
The result of your transfer =  61310.10
The result of your transfer =  56312.55
The result of your transfer =  9216.36
$ python3 Py-CurrencyConverter.py
Dollar exchange rate:  61.3101
Euro exchange rate:  62.5695
Yuan exchange rate:  92.1636
1) Convert to dollars, Euros, yuan
2) Transfer from dollars, Euros, yuan
Choose your actions:
3
Error! Enter only 1 or 2
$ g++ Cpp-CurrencyConverter.cpp -o output
$ ./output
current dollar data: 61.3101
current euro data: 62.5695
current yuan data: 92.1636
1) Convert to dollars, Euros, yuan
2) Transfer from dollars, Euros, yuan
Choose your actions: 1
Enter the number of rubles: 500
The result of your transfer = 8.15526
The result of your transfer = 7.99111
The result of your transfer = 5.42514
$ ./output
current dollar data: 61.3101
current euro data: 62.5695
current yuan data: 92.1636
1) Convert to dollars, Euros, yuan
2) Transfer from dollars, Euros, yuan
Choose your actions: 2
Enter the number of dollars: 1000
Enter the number of euroes: 900
Enter the number of yuans: 100
The result of your transfer = 61310.1
The result of your transfer = 56312.6
The result of your transfer = 9216.36
$ ./output
current dollar data: 61.3101
current euro data: 62.5695
current yuan data: 92.1636
1) Convert to dollars, Euros, yuan
2) Transfer from dollars, Euros, yuan
Choose your actions: 3
Error! Enter only 1 or 2:
Task:
Создайте простой калькулятор, который запускается через терминал.
Decision:
$ cat Cpp-Calculator.cpp
#include <iostream>
using namespace std;
int main()
{
  string repeat="y";
  while (repeat == "y"){
      int numb1, numb2;
      cout<<("Enter number1: ");
      cin>>numb1;
      cout<<("Enter number2: ");
      cin>>numb2;
      char operation;
      cout<<("Enter the operation: ");
      cin>>operation;
      if (operation == '+')
          cout<<(numb1 + numb2)<<endl;
      else if (operation == '-')
          cout<<(numb1 - numb2)<<endl;
      else if (operation == '*')
          cout<<(numb1 * numb2)<<endl;
      else if (operation == '/'){
          if (numb2 == 0)
              cout<<("You cant divide by zero!")<<endl;
          else
              cout<<(numb1 / numb2)<<endl;
      }else{
          cout<<("Invalid operation")<<endl;
      }
      cout<<("Do you want to continue? (y/n): ");
      cin>>repeat;
      if (repeat == "n"){
          break;
      }
      while (repeat!="y" && repeat!="n"){
          cout<<("Please enter the correct answer (y/n): ");
          cin>>repeat;
      }
  }
  return 0;
}
$ cat Py-Calculator.py
repeat="y"
while repeat == "y":
    numb1, numb2 = int(input("Enter number1: ")), int(input("Enter number2: "))
    operation = input("Enter the operation: ")
    if operation == '+':
        print(numb1 + numb2)
    elif operation == '-':
        print(numb1 - numb2)
    elif operation == '*':
        print(numb1 * numb2)
    elif operation == '/':
        if numb2 == 0:
            print('You cant divide by zero!')
        else:
            print(numb1 / numb2)
    else:
        print('Invalid operation')
    repeat = input("Do you want to continue? (y/n): ")
    if repeat == "n":
        break
    while (repeat!="y" and repeat!="n"):
        repeat = input("Please enter the correct answer (y/n): ")
$ python3 Py-Calculator.py
Enter number1: 16
Enter number2: 0
Enter the operation: /
You cant divide by zero!
Do you want to continue? (y/n): t
Please enter the correct answer (y/n): t
Please enter the correct answer (y/n): y
Enter number1: 16
Enter number2: 1
Enter the operation: t
Invalid operation
Do you want to continue? (y/n): y
Enter number1: 16
Enter number2: 1
Enter the operation: -
15
Do you want to continue? (y/n): n
$ g++ Cpp-Calculator.cpp -o output
$ ./output
Enter number1: 16
Enter number2: 0
Enter the operation: /
You cant divide by zero!
Do you want to continue? (y/n): t
Please enter the correct answer (y/n): t
Please enter the correct answer (y/n): y
Enter number1: 16
Enter number2: 1
Enter the operation: t
Invalid operation
Do you want to continue? (y/n): y
Enter number1: 16
Enter number2: 1
Enter the operation: -
15
Do you want to continue? (y/n): n
Task:
Планировщик задач.
Планирование и автоматический запуск сценариев по времени
Decision:
$ python3 -m venv Py-SchedulingAndAutorunScriptsByTime
$ source Py-SchedulingAndAutorunScriptsByTime/bin/activate
$ pip list
Package       Version
------------- -------
pip           20.0.2
pkg-resources 0.0.0
setuptools    44.0.0
$ pip install schedule requests
$ pip list
Package            Version
------------------ ---------
certifi            2022.6.15
charset-normalizer 2.1.0
idna               3.3
pip                20.0.2
pkg-resources      0.0.0
requests           2.28.1
schedule           1.1.0
setuptools         44.0.0
urllib3            1.26.10
$ vim Py-SchedulingAndAutorunScriptsByTime.py
$ python Py-SchedulingAndAutorunScriptsByTime.py
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
$ cat Py-SchedulingAndAutorunS
criptsByTime.py
import schedule
import requests
def greeting():
    todos_dict={
        '08:00':'Drink coffee',
        '11:00':'Work meeting',
        '23:59':'Hack the Planet!'
    }
    print("day's tasks")
    for k, v in todos_dict.items():
        print(f'{k}-{v}')
def main():
    greeting()
if __name__=='__main__':
    main()
Decision:
$ vim Py-SchedulingAndAutorunScriptsByTime.py
$ python Py-SchedulingAndAutorunScriptsByTime.py
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
{'btc_usd': {'high': 24399.99999999, 'low': 22401.00005001, 'avg': 23400.500025, 'vol': 45134.35781963, 'vol_cur': 1.92382651, 'last': 23953.00002, 'buy': 23958.50007, 'sell': 24195.2, 'updated': 1658287860}}
$ cat Py-SchedulingAndAutorunScriptsByTime.py
import schedule
import requests
def greeting():
    todos_dict={
        '08:00':'Drink coffee',
        '11:00':'Work meeting',
        '23:59':'Hack the Planet!'
    }
    print("day's tasks")
    for k, v in todos_dict.items():
        print(f'{k}-{v}')
    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
    data = response.json()
    print(data)
def main():
    greeting()
if __name__=='__main__':
    main()
Decision:
$ vim Py-SchedulingAndAutorunScriptsByTime.py
$ python Py-SchedulingAndAutorunScriptsByTime.py
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
23953.00002
$ cat Py-SchedulingAndAutorunScriptsByTime.py
import schedule
import requests
def greeting():
    todos_dict={
        '08:00':'Drink coffee',
        '11:00':'Work meeting',
        '23:59':'Hack the Planet!'
    }
    print("day's tasks")
    for k, v in todos_dict.items():
        print(f'{k}-{v}')
    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
    data = response.json()
    #print(data)
    btc_price = data.get('btc_usd').get('last')
    print(btc_price)
def main():
    greeting()
if __name__=='__main__':
    main()
Decision:
$ vim Py-SchedulingAndAutorunScriptsByTime.py
$ python Py-SchedulingAndAutorunScriptsByTime.py
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
BTC: 23953.0$
$ cat Py-SchedulingAndAutorunScriptsByTime.py
import schedule
import requests
def greeting():
    todos_dict={
        '08:00':'Drink coffee',
        '11:00':'Work meeting',
        '23:59':'Hack the Planet!'
    }
    print("day's tasks")
    for k, v in todos_dict.items():
        print(f'{k}-{v}')
    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
    data = response.json()
    #print(data)
    #btc_price = data.get('btc_usd').get('last')
    btc_price = f"BTC: {round(data.get('btc_usd').get('last'), 2)}$\n"
    print(btc_price)
def main():
    greeting()
if __name__=='__main__':
    main()
Decision:
$ vim Py-SchedulingAndAutorunScriptsByTime.py
$ python Py-SchedulingAndAutorunScriptsByTime.py
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
BTC: 23953.0$
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
BTC: 23953.0$
day's tasks
08:00-Drink coffee
11:00-Work meeting
23:59-Hack the Planet!
BTC: 23953.0$
^CTraceback (most recent call last):
  File "Py-SchedulingAndAutorunScriptsByTime.py", line 24, in <module>
    main()
  File "Py-SchedulingAndAutorunScriptsByTime.py", line 22, in main
    schedule.run_pending()
  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 780, in run_pending
    default_scheduler.run_pending()
  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 99, in run_pending
    for job in sorted(runnable_jobs):
  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 98, in <genexpr>
    runnable_jobs = (job for job in self.jobs if job.should_run)
  File "/mnt/c/Users/david/Documents/MySkills/Py-Lessons/Py-SchedulingAndAutorunScriptsByTime/lib/python3.8/site-packages/schedule/__init__.py", line 636, in should_run
    @property
KeyboardInterrupt
$ cat Py-SchedulingAndAutorunScriptsByTime.py
import schedule
import requests
def greeting():
    todos_dict={
        '08:00':'Drink coffee',
        '11:00':'Work meeting',
        '23:59':'Hack the Planet!'
    }
    print("day's tasks")
    for k, v in todos_dict.items():
        print(f'{k}-{v}')
    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
    data = response.json()
    #print(data)
    #btc_price = data.get('btc_usd').get('last')
    btc_price = f"BTC: {round(data.get('btc_usd').get('last'), 2)}$\n"
    print(btc_price)
def main():
    #greeting()
    schedule.every(4).seconds.do(greeting)
    while True:
        schedule.run_pending()
if __name__=='__main__':
    main()
Decision:
$ cat Py-SchedulingAndAutorunScriptsByTime.py
import schedule
import requests
def greeting():
    todos_dict={
        '08:00':'Drink coffee',
        '11:00':'Work meeting',
        '23:59':'Hack the Planet!'
    }
    print("day's tasks")
    for k, v in todos_dict.items():
        print(f'{k}-{v}')
    response = requests.get(url='https://yobit.net/api/3/ticker/btc_usd')
    data = response.json()
    #print(data)
    #btc_price = data.get('btc_usd').get('last')
    btc_price = f"BTC: {round(data.get('btc_usd').get('last'), 2)}$\n"
    print(btc_price)
def main():
    #greeting()
    '''schedule.every(4).seconds.do(greeting)
    schedule.every(5).minutes.do(greeting)
    schedule.every().hour.do(greeting)'''
    schedule.every().day.at('12:00').do(greeting)
    schedule.every().thursday.do(greeting)
    schedule.every().friday.at('23:45').do(greeting)
    while True:
        schedule.run_pending()
if __name__=='__main__':
    main()
$ deactivate
Task:
Как определить местоположение с помощью IIP
Decision:
$ python3 -m venv Py-HowToDetermineTheLocationByIp
$ source Py-HowToDetermineTheLocationByIp/bin/activate
$ pip install requests pyfiglet
$ vim Py-HowToDetermineTheLocationByIp.py
$ python Py-HowToDetermineTheLocationByIp.py
Please enter a target IP: 222.12.154.103
{'status': 'success', 'country': 'Japan', 'countryCode': 'JP', 'region': '27', 'regionName': 'Ōsaka', 'city': 'Osaka', 'zip': '540-0002', 'lat': 34.6937, 'lon': 135.502, 'timezone': 'Asia/Tokyo', 'isp': 'Kddi Corporation', 'org': 'DION (KDDI CORPORATION)', 'as': 'AS2516 KDDI CORPORATION', 'query': '222.12.154.103'}
$ cat Py-HowToDetermineTheLocationByIp.py
import requests
def get_info_by_ip(ip='127.0.0.1'):
    try:
        response = requests.get(url=f'http://ip-api.com/json/{ip}').json()
        print(response)
    except requests.exceptions.ConnectionError:
        print('[!] Please check your connection!')
def main():
    ip = input('Please enter a target IP: ')
    get_info_by_ip(ip=ip)
if __name__ == '__main__':
    main()
Decision:
$ vim Py-HowToDetermineTheLocationByIp.py
$ python Py-HowToDetermineTheLocationByIp.py
    ________     _____   ____________
   /  _/ __ \   /  _/ | / / ____/ __ \
   / // /_/ /   / //  |/ / /_  / / / /
 _/ // ____/  _/ // /|  / __/ / /_/ /
/___/_/      /___/_/ |_/_/    \____/
Please enter a target IP: 222.12.154.103
[IP] : 222.12.154.103
[Int prov] : Kddi Corporation
[Org] : DION (KDDI CORPORATION)
[Country] : Japan
[Region Name] : Ōsaka
[City] : Osaka
[ZIP] : 540-0002
[Lat] : 34.6937
[Lon] : 135.502
$ cat Py-HowToDetermineTheLocationByIp.py
import requests
from pyfiglet import Figlet
def get_info_by_ip(ip='127.0.0.1'):
    try:
        response = requests.get(url=f'http://ip-api.com/json/{ip}').json()
        #print(response)
        data = {
            '[IP]': response.get('query'),
            '[Int prov]': response.get('isp'),
            '[Org]': response.get('org'),
            '[Country]': response.get('country'),
            '[Region Name]': response.get('regionName'),
            '[City]': response.get('city'),
            '[ZIP]': response.get('zip'),
            '[Lat]': response.get('lat'),
            '[Lon]': response.get('lon'),
        }
        for k, v in data.items():
            print(f'{k} : {v}')
    except requests.exceptions.ConnectionError:
        print('[!] Please check your connection!')
def main():
    preview_text = Figlet(font='slant')
    print(preview_text.renderText('IP INFO'))
    ip = input('Please enter a target IP: ')
    get_info_by_ip(ip=ip)
if __name__ == '__main__':
    main()
Decision:
$ pip install folium
$ vim Py-HowToDetermineTheLocationByIp.py
$ python Py-HowToDetermineTheLocationByIp.py
    ________     _____   ____________
   /  _/ __ \   /  _/ | / / ____/ __ \
   / // /_/ /   / //  |/ / /_  / / / /
 _/ // ____/  _/ // /|  / __/ / /_/ /
/___/_/      /___/_/ |_/_/    \____/
Please enter a target IP: 222.12.154.103
[IP] : 222.12.154.103
[Int prov] : Kddi Corporation
[Org] : DION (KDDI CORPORATION)
[Country] : Japan
[Region Name] : Ōsaka
[City] : Osaka
[ZIP] : 540-0002
[Lat] : 34.6937
[Lon] : 135.502
$ ls 222.12.154.103_Osaka.html
222.12.154.103_Osaka.html
$ cat Py-HowToDetermineTheLocationByIp.py
import requests
from pyfiglet import Figlet
import folium
def get_info_by_ip(ip='127.0.0.1'):
    try:
        response = requests.get(url=f'http://ip-api.com/json/{ip}').json()
        #print(response)
        data = {
            '[IP]': response.get('query'),
            '[Int prov]': response.get('isp'),
            '[Org]': response.get('org'),
            '[Country]': response.get('country'),
            '[Region Name]': response.get('regionName'),
            '[City]': response.get('city'),
            '[ZIP]': response.get('zip'),
            '[Lat]': response.get('lat'),
            '[Lon]': response.get('lon'),
        }
        for k, v in data.items():
            print(f'{k} : {v}')
        area = folium.Map(location=[response.get('lat'), response.get('lon')])
        area.save(f'{response.get("query")}_{response.get("city")}.html')
    except requests.exceptions.ConnectionError:
        print('[!] Please check your connection!')
def main():
    preview_text = Figlet(font='slant')
    print(preview_text.renderText('IP INFO'))
    ip = input('Please enter a target IP: ')
    get_info_by_ip(ip=ip)
if __name__ == '__main__':
    main()
$ deactivate
Task:
медицинская клиника.
Результаты анализов приходят в зашифрованном виде в файле medicine.xlsx. На сервере лежат таблицы de.med_an_name, de.med_name для расшифровки показаний. В ответе приложите два файла - скрипт python и результат работы (xlsx).
Легкий режим: Вы забираете данные с листа 'easy'. Нужно отыскать пациентов, у которых не в норме хотя бы один анализ. Вывести телефон, имя, название анализа и заключение 'Повышен' или 'Понижен'. Сохранить в xlsx.
Сложный режим: Вы забираете данные с листа 'hard'. Нужно отыскать пациентов, у которых не в норме два и более анализов. Вывести телефон, имя, название анализа и заключение 'Повышен', 'Понижен' или 'Положительный'. Сохранить в xlsx.
Дополнительно сохраните таблицу с расшифрованными значениями и результатами анализа в таблице xxxx_med_results в базе данных (помните про 4 буквы в начале, идентифицирующие вашу таблицу).
Decision:
$ cat Py-Medicine.py
import pandas as pd
import psycopg2
conn = psycopg2.connect(database = "database",
    host = "host.ru",
    user = "de13ma",
    password = "meriadocbrandybuck",
    port = "5432")
conn.autocommit = False
cursor = conn.cursor()
sel = input('Please select the mode (e/h/q): ') 
while (sel.lower() != "e" or sel.lower() != "h" or sel.lower() != "q"): 
    if sel.lower() == "e": 
        # Чтение из файла
        df = pd.read_excel( 'medicine.xlsx', sheet_name='easy', header=0, index_col=None )
        print( df )
        cursor.execute("CREATE TABLE de13ma.gabn_med_easy (patient_code int, analysis varchar, value numeric);")
        # Выполнение SQL кода вставки в базу данных
        cursor.executemany( """INSERT INTO de13ma.gabn_med_easy (patient_code, analysis, value)
            VALUES (%s, %s, %s)""", df.values.tolist() )
        # Выполнение SQL кода в базе данных с возвратом результата
        #cursor.execute( "SELECT * FROM de.med_an_name" )
        #cursor.execute( "SELECT * FROM de.med_name" )
        cursor.execute("""CREATE TABLE de13ma.gabn_med_easy1 AS (
            SELECT 
                * 
            FROM (
                SELECT 
                        --*
                        dmn.phone,
                        dmn.name,
                        dma.name AS analysis,  
                        (CASE 
                                WHEN dmt.value<dma.min_value 
                                        THEN 'Понижен'
                                WHEN dmt.value>dma.max_value 
                                        THEN 'Повышен'
                        --ELSE
                          --'Это нормально'
                        END) AS results--,
                        --dmt.value,
                        --dma.min_value,
                        --dma.max_value 
                FROM de13ma.gabn_med_easy AS dmt
                LEFT JOIN de.med_name AS dmn
                        ON dmt.patient_code = dmn.id
                LEFT JOIN de.med_an_name AS dma
                        ON dmt.analysis = dma.id
                ) AS temp_result
                WHERE results IS NOT null);""")
        conn.commit()
        cursor.execute("SELECT * from de13ma.gabn_med_easy1;")
        records = cursor.fetchall()
        for row in records:
            print( row )
        # Формирование DataFrame
        names = [ x[0] for x in cursor.description ]
        df = pd.DataFrame( records, columns = names )
        df
        print( df )
        # Запись в файл
        df.to_excel( 'gabn_med_res_e.xlsx', sheet_name='easy', header=True, index=False )
        break; 
    elif sel.lower() == "h": 
        df = pd.read_excel( 'medicine.xlsx', sheet_name='hard', header=0, index_col=None )
        print( df )
        cursor.execute("CREATE TABLE de13ma.gabn_med_hard (patient_code int, analysis varchar, value varchar);")
        cursor.executemany( """INSERT INTO de13ma.gabn_med_hard (patient_code, analysis, value)
            VALUES (%s, %s, %s)""", df.values.tolist() )
        cursor.execute("""create table de13ma.gabn_med_hard1 as (
	    with t2 as (
	        select 
		    name,
		    count(*) as cnt 
		from (
		    select 
			--*,
			mn.phone,
			mn.name,
			man.name AS analysis,
			(case 
		            when 
			        lower(gmh.value) = 'положит.' 
				or lower(gmh.value) = 'положительно' 
				or lower(gmh.value) = '+' 
			    then 
			        'Положительный'
			    when 
				lower(gmh.value) = 'отриц.'
				or lower(gmh.value) = '-' 
				or lower(gmh.value) = 'отр' 
			    then 
				'Отрицательный'
			    when 
				cast(gmh.value as numeric) > cast(man.max_value as numeric)
			    then 
				'Повышен' 
			    when 
				cast(gmh.value as numeric) < cast(man.min_value as numeric)
			    then 
				'Понижен'
			    when 
			    	cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
				and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
			    then 
				'Это нормально'
                        else 
			    'Не определено'  
			end) as results--,		
			--gmh.value,
			--man.min_value,
			--man.max_value
			from de13ma.gabn_med_hard as gmh
			left join de.med_name as mn
			    on gmh.patient_code = mn.id
			left join de.med_an_name as man
			    on gmh.analysis = man.id
			where 
			    (case 
			        when 
				    lower(gmh.value) = 'положит.' 
				    or lower(gmh.value) = 'положительно' 
				    or lower(gmh.value) = '+' 
				then 
				    'Положительный'
				when 
				    lower(gmh.value) = 'отриц.'
				    or lower(gmh.value) = '-' 
				    or lower(gmh.value) = 'отр' 
				then 
				    'Отрицательный'
				when 
				    cast(gmh.value as numeric) > cast(man.max_value as numeric)
				then 
				    'Повышен' 
				when 
				    cast(gmh.value as numeric) < cast(man.min_value as numeric)
				then 
				    'Понижен'
				when 
				    cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
				    and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
				then 
				    'Это нормально'
			    else 
				'Не определено'  
			    end) in ('Положительный', 'Повышен' ,'Понижен')) as t1
		        group by name
		        having count(*) > 1)
	            select 
		        * 
	            from (
		        select 
			    --*,
			    mn.phone,
			    mn.name,
			    man.name AS analysis,
			    (case 
				when 
				    lower(gmh.value) = 'положит.' 
				    or lower(gmh.value) = 'положительно' 
				    or lower(gmh.value) = '+' 
				then 
				    'Положительный'
				when 
				    lower(gmh.value) = 'отриц.'
				    or lower(gmh.value) = '-' 
				    or lower(gmh.value) = 'отр' 
				then 
				    'Отрицательный'
				when 
				    cast(gmh.value as numeric) > cast(man.max_value as numeric)
				then 
				    'Повышен' 
				when 
				    cast(gmh.value as numeric) < cast(man.min_value as numeric)
				then 
				    'Понижен'
				when 
				    cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
				    and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
				then 
				    'Это нормально'
			    else 
				'Не определено'  
			    end) as results--,		
			    --gmh.value,
			    --man.min_value,
			    --man.max_value
		            from de13ma.gabn_med_hard as gmh
		            left join de.med_name as mn
			        on gmh.patient_code = mn.id
		            left join de.med_an_name as man
			        on gmh.analysis = man.id
		            where 
			        (case 
				    when 
				        lower(gmh.value) = 'положит.' 
					or lower(gmh.value) = 'положительно' 
					or lower(gmh.value) = '+' 
				    then 
					'Положительный'
				    when 
					lower(gmh.value) = 'отриц.'
					or lower(gmh.value) = '-' 
					or lower(gmh.value) = 'отр' 
				    then 
					'Отрицательный'
				    when 
					cast(gmh.value as numeric) > cast(man.max_value as numeric)
				    then 
					'Повышен' 
				    when 
					cast(gmh.value as numeric) < cast(man.min_value as numeric)
				    then 
					'Понижен'
				    when 
					cast(gmh.value as numeric) >= cast(man.min_value as numeric)  
					and cast(gmh.value as numeric) <= cast(man.max_value as numeric)  
				    then 
					'Это нормально'
			        else 
				    'Не определено'  
			        end) in ('Положительный', 'Повышен' ,'Понижен')) as t1
	                where name in (
		            select 
			        name 
		            from t2)
	                order by name, results);""")
        conn.commit()
        cursor.execute("SELECT * from de13ma.gabn_med_hard1;")
        records = cursor.fetchall()
        for row in records:
            print( row )
        # Формирование DataFrame
        names = [ x[0] for x in cursor.description ]
        df = pd.DataFrame( records, columns = names )
        df
        print( df )
        # Запись в файл
        df.to_excel( 'gabn_med_res_h.xlsx', sheet_name='easy', header=True, index=False )
        break; 
    elif sel.lower() == "q":
        break;
    else: 
        sel = input('Please select the mode (e/h/q): ')
# Закрываем соединение
cursor.close()
conn.close()
Task:
Code Review.
На обработку поступает последовательность из 8 целых чисел. Известно, что вводимые числа по абсолютной величине не превышают 10^12. Нужно написать программу, которая выводит на экран количество делящихся нацело на 4 чисел в исходной последовательности и максимальное делящееся нацело на 4 число. Если делящихся нацело на 4 чисел нет, требуется на экран вывести «NO». Программист торопился и написал программу неправильно.
Найдите все ошибки в этой программе (их может быть одна или несколько). Известно, что каждая ошибка затрагивает только одну строку и может быть исправлена без изменения других строк.
Decision:
n = 8 # n = 7, по условию чисел 8
count = 0
maximum = -10**6 - 1 # maximum = 1000, все случаи, когда все числа меньше 1000, обрабатываются неверно
for i in range(1, n + 1):
    x = int(input())
    if x % 4 == 0: # x // 4 == 0, по условию нужно найти числа, дел. на 4 без остатка
        count += 1
        if x > maximum: # if x < maximum, если число больше максимума, оно его заменяет, не если меньше максимума
            maximum = x
if count > 0:
    print(count)
    print(maximum)
else:
    print('NO')
Task:
На обработку поступает последовательность из 4 целых чисел. Известно, что вводимые числа по абсолютной величине не превышают 10^8. Нужно написать программу, которая выводит на экран количество нечётных чисел в исходной последовательности и максимальное нечётное число. Если нечётных чисел нет, требуется на экран вывести «NO». Программист торопился и написал программу неправильно.
Найдите все ошибки в этой программе (их может быть одна или несколько). Известно, что каждая ошибка затрагивает только одну строку и может быть исправлена без изменения других строк.
Decision:
#n = 4
count = 0
maximum = -1
for i in range(4):
    x = int(input())
    if x % 2 != 0:
        count += 1
        if x > maximum:
            maximum = x
            #break
if count > 0:
    print(count)
    print(maximum)
else:
    print('NO')
Task:
Color Mixer.
Красный, синий и желтый называются основными цветами, потому что их нельзя получить путем смешения других цветов. При смешивании двух основных цветов получается вторичный цвет:
    если смешать красный и синий, то получится фиолетовый;
    если смешать красный и желтый, то получится оранжевый;
    если смешать синий и желтый, то получится зеленый.
Напишите программу, которая считывает названия двух основных цветов для смешивания. Если пользователь вводит что-нибудь помимо названий «красный», «синий» или «желтый», то программа должна вывести сообщение об ошибке. В противном случае программа должна вывести название вторичного цвета, который получится в результате.
Decision:
color1, color2 = input(), input()
if color1 == 'красный' and color2 == 'синий' or (color1 == 'синий' and color2 == 'красный'):
    print('фиолетовый')
elif color1 == 'желтый' and color2 == 'синий' or (color1 == 'синий' and color2 == 'желтый'):
    print('зеленый')
elif color1 == 'красный' and color2 == 'желтый' or (color1 == 'желтый' and color2 == 'красный'):
    print('оранжевый')
elif color1 == 'красный' and color2 == 'красный' or color1 == 'желтый' and color2 == 'желтый' or color1 == 'синий' and color2 == 'синий':
    print(color1)
else:
    print('ошибка цвета')
Task:
Pin Ball
Decision:
#1) создать поле
from tkinter import *#1
import random #44) Содаем отскок
WIDTH=900#2 настройки окна глоб переменная
HEIGHT=300#3 настройки окна глоб переменная
PAD_W=10#ракетка
PAD_H=100#ракетка
BALL_RADIUS=40#мяч
#15) двигаем мяч
BALL_X_CHANCGE=20#16 переменная для скорости мяча, горизонтально и вертикально
BALL_Y_CHANCGE=0#16
root=Tk()#7
root.title("Ping-pong")#8
c=Canvas(root,
         width=WIDTH,
         height=HEIGHT,
         background="#008B8B")#9 создаем область, в котором все это делается
c.pack()#10 ставим наш канвас
c.create_line(PAD_W,
              0,
              PAD_W,
              HEIGHT,
              fill="white")#11 Сделаем левую и правую ракетку на поле, мяч и линию, он будет касаться
c.create_line(WIDTH-PAD_W,
              0,
              WIDTH-PAD_W,
              HEIGHT,
              fill="white")#11 Вычитаем, потому что с обратной стороны, для правой ракетки
c.create_line(WIDTH/2,
              0,
              WIDTH/2,
              HEIGHT,
              fill="white")#12 сделаем линию, которая разделяет игровое поле
BALL=c.create_oval(WIDTH/2-BALL_RADIUS/2,
                   HEIGHT/2-BALL_RADIUS/2,
                   WIDTH/2+BALL_RADIUS/2,
                   HEIGHT/2+BALL_RADIUS/2, fill="#FF4500")#13 создаем мяч
LEFT_PAD=c.create_line(PAD_W/2,
                       0,
                       PAD_W/2,
                       PAD_H,
                       width=PAD_W,
                       fill="#DA70D6")#13 создаем левую и правую ракетку, чтоб они просто были
RIGHT_PAD=c.create_line(WIDTH-PAD_W/2,
                        0,
                        WIDTH-PAD_W/2,
                        PAD_H,
                        width=PAD_W,
                        fill="#DA70D6")#13
PLAYER1_SCORE=0#66) считаем очки и возвращаем мяч на изначальную точку
PLAYER2_SCORE=0
#68 нужны функции смена счета и функции смены положения мяча
INITIAL_SPEED=20#69 переменная для счета скорости
p_1_text=c.create_text(WIDTH-WIDTH/6,
                       PAD_H/4,
                       text=PLAYER1_SCORE,
                       font='Arial 20',
                       fill='aqua')#67 создаем текст очков
p_2_text=c.create_text(WIDTH/6,
                       PAD_H/4,
                       text=PLAYER2_SCORE,
                       font='Arial 20',
                       fill='aqua')
#22) создаем упраление ракетами
PAD_SPEED=20#23 задаем сначала общую скорость ракетки
LEFT_PAD_SPEED=0#24  скорость левой и правой ракетки, задаем 0, ибо изначально она не двигается
RIGHT_PAD_SPEED=0#24
BALL_SPEED_UP=1.00#45 скорость мяча с каждым ударом
BALL_MAX_SPEED=30#46 максимальная скорость мяча
BALL_X_SPEED=20#47 начальная скорость по горизонтали
BALL_Y_SPEED=20#48 po vertikali
right_line_distance=WIDTH-PAD_W#49 расстояние да правого края
def update_score(player):#70  создадим функцию, которая будет обнвлять счет
    global PLAYER1_SCORE, PLAYER2_SCORE
    if player=='right':
        PLAYER1_SCORE+=1
        c.itemconfig(p_1_text, text=PLAYER1_SCORE)
    else:
        PLAYER2_SCORE+=1
        c.itemconfig(p_2_text, text=PLAYER2_SCORE)
def spawn_ball():#71 respoun
    global BALL_X_SPEED#72
    c.coords(BALL,
             WIDTH/2-BALL_RADIUS/2,
             HEIGHT/2-BALL_RADIUS/2,
             WIDTH/2+BALL_RADIUS/2,
             HEIGHT/2+BALL_RADIUS/2)#73
    BALL_X_SPEED=-(BALL_X_SPEED*INITIAL_SPEED)/abs(BALL_X_SPEED)#74
def bounce(actiom):#50 напишем функию, которая будет отскакиать мяч
    global BALL_X_SPEED, BALL_Y_SPEED#51 переменные, которые понадобятся для мяча
    if actiom=='strike':#52 если ужарим ракеткй, то мы повернем в случайном направлении от -10 дo +10
        BALL_Y_SPEED=random.randrange(-10, 10)#52
        if abs(BALL_X_SPEED)<BALL_MAX_SPEED:#53 и если скорость мяча < скорости максимального мяча, то мы эту скорость увеличим
            BALL_X_SPEED *= -BALL_SPEED_UP
        else:#54 иначе оставляем ее на месте
            BALL_X_SPEED= -BALL_X_SPEED
    else:#55
        BALL_Y_SPEED= -BALL_Y_SPEED#56
def move_ball():#17 Сделаем функцию движения мяча
    #57c.move(BALL, BALL_X_CHANCGE, BALL_Y_CHANCGE)#18 двигаем мяча по определенному скорости
    ball_left, ball_top, ball_right, ball_bot=c.coords(BALL) # 58 нужно переписать движение мяча с учетом движения, которое мы написали в функции bounce. то есть нужно определять координаты мяча oт центра
    ball_center=(ball_top+ball_bot)/2#59 теперь нужно это все определеить, например центр
    if ball_right + BALL_X_SPEED < right_line_distance and  ball_left +BALL_X_SPEED > PAD_W:#60 теперь нужно сделатьь так, чтоб вертикально отскакивал
        c.move(BALL, BALL_X_SPEED, BALL_Y_SPEED)#61 тогда двигаем дальше
    elif ball_right==right_line_distance or ball_left==PAD_W:#62 проверяем, проверим какой именно стороны поля мы коснулись, если правой стороны -сравниваем позицию центра мяча, и если мяч в пределах ракетки, то делаем отскок
        if ball_right>WIDTH/2:
            if c.coords(RIGHT_PAD)[1]<ball_center<c.coords(RIGHT_PAD)[3]:
                bounce('strike')#63 тогда мы делаем отскок
            else:
                #76pass
                update_score('left')#77
                spawn_ball()#78
        else:
            if c.coords(LEFT_PAD)[1]<ball_center<c.coords(LEFT_PAD)[3]:
                bounce('strike')#63 тогда мы делаем отскок
            else:
                #76pass
                update_score('right')#77
                spawn_ball()#78    else:#64 теперь нужно проверить момент, когда мяч выходит за пределы игрового поля
    else:
        if ball_right > WIDTH/2:
            c.move(BALL,
                   right_line_distance-ball_right,
                   BALL_Y_SPEED)
        else:
            c.move(BALL,
                   -ball_left+PAD_W,
                   BALL_Y_SPEED)
    if ball_top+BALL_Y_SPEED<0 or ball_bot+BALL_Y_SPEED>HEIGHT:
        bounce('ricochet')
        #65 на экране мы должны увидеть отскок
def move_pads():#25 напишим функию двжиения обих ракеток сразу
    PADS={LEFT_PAD: LEFT_PAD_SPEED,
          RIGHT_PAD: RIGHT_PAD_SPEED}#26 нужно сделать так чтоб левая ракеткка двигалась ско скорость левой ракеткой, а праввая - правой. для этого создаим словарик
    for pad in PADS:#27 теперь нужно перебррать ракетки, и двигать с заданной скоростью, черех цикл FOR
        c.move(pad, 0, PADS[pad])#27
        if c.coords(pad)[1]<0:#28 Если ракетка входит выше поля, то мы ее возращаем на место
            c.move(pad, 0, -c.coords(pad)[1])#29 отталкиваем нашу ракетку
        elif c.coords(pad)[3]>HEIGHT:#30 если снизу, то отталкиваем вниз
            c.move(pad, 0, HEIGHT-c.coords(pad)[3])#30
def main():#19  main вызывает функию move_ball при помощи рекурсии
    move_ball()#19
    move_pads()# 31 вставим move_pads в функцию main,  чтоб когда мы вызывали эту функциюу нас не только летел, но идвигались наши ракетки
    root.after(30, main)#20
c.focus_get()#32 фокус на сanvas, чтоб реагировал на нажатие клавиши
def moveent_hadeler(event):#33 функция обработки нажатия клавиш
    global LEFT_PAD_SPEED, RIGHT_PAD_SPEED#34
    if event.keysym=='w':#35
        LEFT_PAD_SPEED= -PAD_SPEED#36 когда мы нажимаем верх, ракетка должна идти верх
    elif event.keysym=='s':#36
        LEFT_PAD_SPEED= PAD_SPEED#36
    elif event.keysym=='Up':#37 для 2ой ракетки
        RIGHT_PAD_SPEED= -PAD_SPEED
    elif event.keysym=='Down':#37 для 2ой ракетки
        RIGHT_PAD_SPEED= PAD_SPEED
c.bind("<KeyPress>", moveent_hadeler)#38 теперь нужно привязывать Сanvas  эту функцию
#39 po idee na ekrane dlojni reagirovat uje raketki, klavishi, a zdes ERROR 15:46
def stop_pad(event):#40 сделаем функцию реагирования на отпускания
    global LEFT_PAD_SPEED, RIGHT_PAD_SPEED#41
    if event.keysym in 'ws':#42 если эти клавиши не нажаты, то мы ставим скорость 0
        LEFT_PAD_SPEED=0
    elif event.keysym in ('Up', 'Down'):
        RIGHT_PAD_SPEED=0
c.bind("<KeyRelease>", stop_pad)#43 делаем привязку этой функцииdelaem privyazku etoi funkcii
main()#21 запуск самого двжиения
root.mainloop()#14 запуск окна
Task:
Snake
Decision:
import pygame, random, sys, time
"""print("hello")
def privet():
    error = pygame.init()
    if error[1]==0:
        print("Hello! It's been a rain, weather")
    else:
        print("error detected!")
        sys.exit()
privet()
#выводит, что было выполненно 6 команд, и 0 ошибок
"""
playSurface=pygame.display.set_mode((800,600)) # Создаем экран
pygame.display.set_caption("Snake") # Даем имя экрану
#time.sleep(56)
position=[50, 50] # Координаты змейки
body=[[80,50],[70,50],[60,50]] # Структура тела змейки
bait=[random.randrange(1,80)*10, random.randrange(1,60)*10] # Пища
baitVisible=True
fpsController=pygame.time.Clock()
direction='RIGHT' # Направление движения
changeto=direction # Изменение направления
score=0 # Игровой счет
"""
Нужно еще создать цвета, таблица цветов rgb - google
color=pygame.Color(r,b,a)
"""
white=pygame.Color(255,255,255) # Фон
black=pygame.Color(0,0,0) # Конец игры
red=pygame.Color(255,0,0) # Шрифт
green=pygame.Color(0,255,0) # Змейка
blue=pygame.Color(0,0,255)
lightslateblue=pygame.Color(132,112,255) # Пища для змейки
def gameOver():
"""
Сделаем надпись, которая будет появляться в конце игры.
Чтобы несколько раз не писать pygame, мы объекту передаем дополнительные
параметры
"""
    gaOFont=pygame.font.SysFont('Garamond', 48)
# Объект, который отвечает за шрифт, и то, какой будет шрифт
    gaOSurface=gaOFont.render('Game over!', True, white)
"""
Здесь нужно было создать надпись GAMEOVER. Для этого мы используем Функцию render,
которая отвечает за то, чтобы создать саму надпись
"""
    gaORectangular=gaOSurface.get_rect()
    gaORectangular.midtop=(400, 25) # Тут задаем координаты для надписи
    playSurface.blit(gaOSurface, gaORectangular)
""" blit отвечает за то, что бы нарисовать 1 объект поверх другого, т.е.
поверх gaOSurface нужно разместить gaORectangular
"""
    showScore(2) # Строим счетчик
    pygame.display.flip()
"""
Выводим на экран воображаемые объекты. Если эту строку не писать, то мы увидим
пустой экра. flip - прописывает то, что мы написали в коде
"""
    time.sleep(8) # Задержка
    pygame.quit()
# Чтобы игра была завершена технически, нужно закончить pygame 
    sys.exit() # Чтобы закончить саму программу в Питоне
def showScore (choice=1):
    scoreFont=pygame.font.SysFont('Garamond', 24)
    scoreSurface=scoreFont.render('Score: {0}'.format(score), True, red)
#   scoreSurface=scoreFont.render('Score:'+str(score), True, red)
    scoreRectangular=scoreSurface.get_rect()
    if choice==1:
        scoreRectangular.midtop=(50, 25)
    else:
        scoreRectangular.midtop=(400, 125)
# Два варианта, которые будут позиционировать блок со шрифтом
    playSurface.blit(scoreSurface, scoreRectangular)
    pygame.display.flip()

#                       Создаем осноной элемент игры
while True:
"""
Сделаем бесконечную игру с помощью цикла.
Игра ждет действие игрока, т.е. во время бесконечного цикла мы будем забирать
событие event
"""
    for event in pygame.event.get(): # очередь событии, т.е. последовательности
"""
Для работы с последовательностью, чтобы работать с каждым элементом в поисках
элемента только с определенным типом. Поэтому используем цикл for
"""
        if event.type == pygame.QUIT:
# Мы каждый раз проверяем не хочет ли игрок выйти из игры
            pygame.guit()
            sys.exit()
# Если хочет игрок выйти, тогда мы закрываем программу
        elif event.type == pygame.KEYDOWN:
# Проверяем на нажатие клавиши, но мы должны посмотреть какую именно клавишу
            if event.key==pygame.K_RIGHT or event.key == ord('d'):
                changeto='RIGHT'
# Если K_RIGHT, то нужно изменить направление
# ord('d') - Кодировка клавиши - 100
            if event.key==pygame.K_LEFT or event.key == ord('a'):
                changeto='LEFT'
            if event.key==pygame.K_UP or event.key == ord('w'):
                changeto='UP'
            if event.key==pygame.K_DOWN or event.key == ord('d'):
                changeto='DOWN'
            if event.key==pygame.K_ESCAPE:
# и рассмотрим случаи, когда работает кнопка ESC
#               pygame.event.post(pygame.event.Event(QUIT))
# Для этого Сделаем метод post, чтобы отправить в очередь событие
                gameOver()
#                   Обработка направления движения змейки
"""
Что делать при смене определения направления движения. определение направления
движения влиеяет на положение Змейки на карте с координатами POSITION[50,50].
Т.е. direction будет влиять на значение Х или У
Мы должны прописать связку, которая образовывает changeto
Представим, что есть Змейка [][][]. Слева хвост, справа голова. и он сейчас
движется вправо, если игрок нажал RIGHT, а если вверх - UP, а это значит, что
голова будет находиться в других координатах
  []
[][]
а потом так
  []
  []
  []
т.е. голова вверху, а хвост внизу. Но если игрок нажмет в таком слуаче вниз, а
это неправильный ход. Сначала голова же должна повернуться, а потом уже внизу.
Именно это нужно сейчас прописать. Сделаем так, чтобы змея не меняла направление
в таких случаях
"""
    if direction != 'LEFT' and changeto == 'RIGHT':
        direction='RIGHT'
    if direction != 'RIGHT' and changeto == 'LEFT':
        direction = 'LEFT'
    if direction != 'UP' and changeto == 'DOWN':
        direction = 'DOWN'
    if direction != 'DOWN' and changeto == 'UP':
        direction = 'UP'
"""
Если направление движения не было вниз, а мы получили указание двигаться вверх,
то мы двигаемся вверх
"""
#                   Изменение позиции в зависимости от направления
    if direction == 'RIGHT':
        position[0] += 10
"""
Мы производим увеличение оси Х, обращаясь к элементу с индексом 0, т.к. Х идет по
этому индексу, а с индексом 1 - У. Поэтому мы меняем значение Х по списке на 10.
10 это то на что мы делим - длины, позиции, и т.д. кратное 10
"""
    if direction == 'LEFT':
        position[0] -= 10 # Влево, значит уменьшенное на 10
    if direction == 'UP':
        position[1] -= 10
    if direction == 'DOWN':
        position[1] += 10
# Тут надо еще учитывать, что оси Х и У в pygame, не такие ккак в математике
"""
Двигается змейка вправо и состоит из 3х блоков
[][][]
При каждом поедании нужно проверить съел ли он пищу (BAIT), и если съел -
увеличить его на один блок
[][][][]
Увлеличение будем осуществлять методом insert в начало списка. А дальше еда
исчезает, добавляется новый блок и пища появляется в другом месте. в новом теле
будем добавлять новый элемент, потом сразу проверим на совпадение координат тела
и координаты пищи. Если совпадение произошло, то будем оставлять новый добавленный
блок, если нет - просто удаляем
"""
#               Работа над длиной тела змейки, увеличение счета
    body.insert(0, list(position))
    if position[0]==bait[0] and position[1]==bait[1]:
        baitVisible=False
        score+=1
    else:
        body.pop() # pop - удаляет последний элемент из списка
#           Ввдимость пишем на карте
    if baitVisible== False:
# Проверим является пища не видимой, потому что она должна появиться сново
        baitVisible=True # Тут рисуем новую пищу
        bait = [random.randrange(1, 80) * 10, random.randrange(1, 60) * 10]  # primanka
# Тут рисуем пищу в другом координате. этот же код был наверху.
    playSurface.fill(white)
# у нас есть элемент поверхностный - PLAYSURFACE, сделаем белым    
"""
Но нам еще нужно прописать тело змейки (BODY, он  состоит из списка), мы можем
прописать эти элементы в списке по очереди, что делаем с помощью цикла for
"""
    for element in body:
        pygame.draw.rect(playSurface, green, pygame.Rect(element[0], element[1], 10, 10))
"""
В библиотеке pygame есть класс DRAW, в этом классе, есть метод RECT(Рисование
прямоугольника), мы передаем ему 3 элемента: поверхность, цвет, и еще 1 кдасс,
который тоже рисует прямоугольник. у него координата Х (element[0]), У, и
отдельно указываем ширину и высоту прямоугольника
"""
# рисуем пищу
    pygame.draw.rect(playSurface, lightslateblue, pygame.Rect(bait[0], bait[1], 10, 10))
# исправляем проблему, когда змейкка выходит за пределы экрана
    if position[0]>790 or position[0]<0:
        position[0]=400
    if position[1]>590 or position[1]<0:
        position[1]=300
# чтоб змейка себя не съела
    for element in body[1: ]:
        if position[0]==element[0] and position[1]==element[1]:
            position=[50,50] # координаты змейки
            body=[[80,50], [70,50], [60,50]] # структура тела змейки
    showScore()
# чтобы выполнилось функция SCRORE счетчик
    fpsController.tick(12)
# чтобы змейка двигаласчь по медленее
    pygame.display.flip()
    Task:
Тетрис
Decision:
import pygame as pg
import random, time, sys
from pygame.locals import *
#Затем определяем основные константы – кадровую частоту fps, высоту и ширину окна программы, размер базового элемента фигур-букв block (20 х 20 пикселей), параметры стакана, символ для обозначения пустых ячеек на игровом поле:
fps = 25
window_w, window_h = 600, 500
block, cup_h, cup_w = 20, 20, 10
#Параметры side_freq и down_freq задают время, которое затрачивается на перемещение фигуры в сторону или вниз, если игрок удерживает клавишу нажатой:
side_freq, down_freq = 0.15, 0.1
#Для размещения стакана и информационных надписей, а также для конвертации координат нам также понадобятся константы side_margin и top_margin – первая задает дистанцию между правой и левой сторонами окна программы и стаканом; вторая определяет расстояние между верхней границей стакана и окном:
side_margin = int((window_w - cup_w * block) / 2)
top_margin = window_h - (cup_h * block) - 5
#Цвета фигур задаются двумя кортежами: colors и lightcolors. Последний включает чуть более светлые оттенки тех же цветов, что и colors – для создания псевдо 2.5 D эффекта.
colors = ((0, 0, 225), (0, 225, 0), (225, 0, 0), (225, 225, 0)) # синий, зеленый, красный, желтый
lightcolors = ((30, 30, 255), (50, 255, 50), (255, 30, 30), (255, 255, 30)) # светло-синий, светло-зеленый, светло-красный, светло-желтый
white, gray, black  = (255, 255, 255), (185, 185, 185), (0, 0, 0)
brd_color, bg_color, txt_color, title_color, info_color = white, black, white, colors[3], colors[0]
#Поскольку каждая фигура состоит из 4 блоков, размер шаблона должен быть 5 х 5: 
fig_w, fig_h = 5, 5
empty = 'o'
#Поскольку каждую фигуру-букву можно поворачивать на 90 градусов, все возможные варианты поворотов описаны в словаре figures с помощью вложенных списков, элементы которых состоят из строк: символом x отмечены занятые ячейки, o – пустые. Количество вращений зависит от формы буквы: у O, к примеру, будет всего один вариант:
figures = {'S': [['ooooo',
                  'ooooo',
                  'ooxxo',
                  'oxxoo',
                  'ooooo'],
                 ['ooooo',
                  'ooxoo',
                  'ooxxo',
                  'oooxo',
                  'ooooo']],
           'Z': [['ooooo',
                  'ooooo',
                  'oxxoo',
                  'ooxxo',
                  'ooooo'],
                 ['ooooo',
                  'ooxoo',
                  'oxxoo',
                  'oxooo',
                  'ooooo']],
           'J': [['ooooo',
                  'oxooo',
                  'oxxxo',
                  'ooooo',
                  'ooooo'],
                 ['ooooo',
                  'ooxxo',
                  'ooxoo',
                  'ooxoo',
                  'ooooo'],
                 ['ooooo',
                  'ooooo',
                  'oxxxo',
                  'oooxo',
                  'ooooo'],
                 ['ooooo',
                  'ooxoo',
                  'ooxoo',
                  'oxxoo',
                  'ooooo']],
           'L': [['ooooo',
                  'oooxo',
                  'oxxxo',
                  'ooooo',
                  'ooooo'],
                 ['ooooo',
                  'ooxoo',
                  'ooxoo',
                  'ooxxo',
                  'ooooo'],
                 ['ooooo',
                  'ooooo',
                  'oxxxo',
                  'oxooo',
                  'ooooo'],
                 ['ooooo',
                  'oxxoo',
                  'ooxoo',
                  'ooxoo',
                  'ooooo']],
           'I': [['ooxoo',
                  'ooxoo',
                  'ooxoo',
                  'ooxoo',
                  'ooooo'],
                 ['ooooo',
                  'ooooo',
                  'xxxxo',
                  'ooooo',
                  'ooooo']],
           'O': [['ooooo',
                  'ooooo',
                  'oxxoo',
                  'oxxoo',
                  'ooooo']],
           'T': [['ooooo',
                  'ooxoo',
                  'oxxxo',
                  'ooooo',
                  'ooooo'],
                 ['ooooo',
                  'ooxoo',
                  'ooxxo',
                  'ooxoo',
                  'ooooo'],
                 ['ooooo',
                  'ooooo',
                  'oxxxo',
                  'ooxoo',
                  'ooooo'],
                 ['ooooo',
                  'ooxoo',
                  'oxxoo',
                  'ooxoo',
                  'ooooo']]}
#Заливку сплошным цветом реализовать очень просто, но полупрозрачную заставку сделать сложнее – как ни странно, метод draw в Pygame до сих пор не поддерживает эту опцию. Есть несколько способов решения этой проблемы. Мы воспользуемся методом, который предусматривает создание дополнительной поверхности с попиксельным альфа-смешением, и последующую заливку экрана паузы цветом с наложением на поверхность окна игры:
def pauseScreen():
    pause = pg.Surface((600, 500), pg.SRCALPHA)
    pause.fill((0, 0, 255, 127))
    display_surf.blit(pause, (0, 0))
#Эта функция отвечает за создание нескольких дополнительных глобальных констант, инициализирует модуль Pygame, рисует стартовое окно игры, вызывает запуск Тетриса runTetris() и в случае необходимости отображает сообщение о проигрыше:
def main():
    global fps_clock, display_surf, basic_font, big_font
    pg.init()
    fps_clock = pg.time.Clock()
    display_surf = pg.display.set_mode((window_w, window_h))
    basic_font = pg.font.SysFont('arial', 20)
    big_font = pg.font.SysFont('verdana', 45)
    pg.display.set_caption('Тетрис Lite')
    showText('Тетрис Lite')
    while True: # начинаем игру
        runTetris()
        pauseScreen()
        showText('Игра закончена')
#Код игры располагается в функции runTetris():
def runTetris():
    cup = emptycup()
    last_move_down = time.time()
    last_side_move = time.time()
    last_fall = time.time()
    going_down = False
    going_left = False
    going_right = False
    points = 0
    level, fall_speed = calcSpeed(points)
    fallingFig = getNewFig()
    nextFig = getNewFig()
    #Основной цикл обрабатывает все основные события, связанные с генерацией фигур, движением вниз и показом следующей фигуры:
    while True: 
        if fallingFig == None:
            # если нет падающих фигур, генерируем новую
            fallingFig = nextFig
            nextFig = getNewFig()
            last_fall = time.time()
            if not checkPos(cup, fallingFig):
                return # если на игровом поле нет свободного места - игра закончена
        quitGame()
        for event in pg.event.get(): 
            if event.type == KEYUP:
                if event.key == K_SPACE:
                    pauseScreen()
                    showText('Пауза')
                    last_fall = time.time()
                    last_move_down = time.time()
                    last_side_move = time.time()
                #Цикл обрабатывает паузу и определяет момент, когда пользователь нажимает и отпускает клавиши со стрелками. Если клавиши →, ← и ↓ не нажаты, значения соответствующих переменных меняются на False:
                elif event.key == K_LEFT:
                    going_left = False
                elif event.key == K_RIGHT:
                    going_right = False
                elif event.key == K_DOWN:
                    going_down = False
            #Управление движением фигур происходит в ветке elif event.type == KEYDOWN: если нажата клавиша со стрелкой и функция checkPos() возвращает True, положение фигуры изменяется на один блок в соответствующем направлении:
            elif event.type == KEYDOWN:
                if event.key == K_LEFT and checkPos(cup, fallingFig, adjX=-1):
                    fallingFig['x'] -= 1
                    going_left = True
                    going_right = False
                    last_side_move = time.time()
                elif event.key == K_RIGHT and checkPos(cup, fallingFig, adjX=1):
                    fallingFig['x'] += 1
                    going_right = True
                    going_left = False
                    last_side_move = time.time()                    
                # поворачиваем фигуру, если есть место
                elif event.key == K_UP:
                    fallingFig['rotation'] = (fallingFig['rotation'] + 1) % len(figures[fallingFig['shape']])
                    #При нажатии ↑ происходит вращение фигуры – варианты берутся из словаря figures. Чтобы не получить ошибку IndexError: list index out of range, мы используем конструкцию, которая обнуляет индекс элемента, когда инкремент достигает максимального значения: fallingFig['rotation'] + 1) % len(figures[fallingFig['shape']]. Если функция checkPos() сообщает, что очередное вращение невозможно из-за того, что фигура натыкается на какой-то блок, нужно вернуться к предыдущему варианту из списка:
                    if not checkPos(cup, fallingFig):
                        fallingFig['rotation'] = (fallingFig['rotation'] - 1) % len(figures[fallingFig['shape']])
                #Для ускорения падения игрок нажимает и удерживает клавишу ↓:
                elif event.key == K_DOWN:
                    going_down = True
                    if checkPos(cup, fallingFig, adjY=1):
                        fallingFig['y'] += 1
                    last_move_down = time.time()
                #Если пользователь хочет мгновенно сбросить фигуру на дно, он может нажать Enter. Цикл for здесь определяет максимально низкую свободную позицию в стакане:
                elif event.key == K_RETURN:
                	going_down = False
                	going_left = False
                	going_right = False
                	for i in range(1, cup_h):
                    	    if not checkPos(cup, fallingFig, adjY=i):
                      	        break
                	fallingFig['y'] += i - 1
        #Чтобы определить, удерживает ли пользователь клавишу движения, программа использует условия:
        if (going_left or going_right) and time.time() - last_side_move > side_freq:
            if going_left and checkPos(cup, fallingFig, adjX=-1):
                fallingFig['x'] -= 1
            elif going_right and checkPos(cup, fallingFig, adjX=1):
                fallingFig['x'] += 1
            last_side_move = time.time()
        if going_down and time.time() - last_move_down > down_freq and checkPos(cup, fallingFig, adjY=1):
            fallingFig['y'] += 1
            last_move_down = time.time()
        #Если пользователь никак не вмешивается в управление фигурой, движение вниз происходит так:
        if time.time() - last_fall > fall_speed: # свободное падение фигуры
            if not checkPos(cup, fallingFig, adjY=1): # проверка "приземления" фигуры
                addToCup(cup, fallingFig) # фигура приземлилась, добавляем ее в содержимое стакана
                points += clearCompleted(cup)
                level, fall_speed = calcSpeed(points)
                fallingFig = None
            else: # фигура пока не приземлилась, продолжаем движение вниз
                fallingFig['y'] += 1
                last_fall = time.time()
        #Функцию runTetris() завершает набор функций, обеспечивающих отрисовку игрового поля, вывод названия игры, падающей и следующих фигур, а также информационных надписей:
        display_surf.fill(bg_color)
        drawTitle()
        gamecup(cup)
        drawInfo(points, level)
        drawnextFig(nextFig)
        if fallingFig != None:
            drawFig(fallingFig)
        pg.display.update()
        fps_clock.tick(fps)
#ункция txtObjects() принимает текст, шрифт и цвет, и с помощью метода render() возвращает готовые объекты Surface (поверхность) и Rect (прямоугольник). Эти объекты в дальнейшем обрабатываются методом blitв функции showText(), выводящей информационные надписи и название игры.
def txtObjects(text, font, color):
    surf = font.render(text, True, color)
    return surf, surf.get_rect()
#Выход из игры обеспечивает функция stopGame(), в которой используется sys.exit() из импортированного в начале кода модуля sys.
def stopGame():
    pg.quit()
    sys.exit()
def checkKeys():
    quitGame()
    for event in pg.event.get([KEYDOWN, KEYUP]):
        if event.type == KEYDOWN:
            continue
        return event.key
    return None
def showText(text):
    titleSurf, titleRect = txtObjects(text, big_font, title_color)
    titleRect.center = (int(window_w / 2) - 3, int(window_h / 2) - 3)
    display_surf.blit(titleSurf, titleRect)
    pressKeySurf, pressKeyRect = txtObjects('Нажмите любую клавишу для продолжения', basic_font, title_color)
    pressKeyRect.center = (int(window_w / 2), int(window_h / 2) + 100)
    display_surf.blit(pressKeySurf, pressKeyRect)
    while checkKeys() == None:
        pg.display.update()
        fps_clock.tick()
def quitGame():
    for event in pg.event.get(QUIT): # проверка всех событий, приводящих к выходу из игры
        stopGame() 
    for event in pg.event.get(KEYUP): 
        if event.key == K_ESCAPE:
            stopGame() 
        pg.event.post(event) 
def calcSpeed(points):
    # вычисляет уровень
    level = int(points / 10) + 1
    fall_speed = 0.27 - (level * 0.02)
    return level, fall_speed
def getNewFig():
    # возвращает новую фигуру со случайным цветом и углом поворота
    shape = random.choice(list(figures.keys()))
    newFigure = {'shape': shape,
                'rotation': random.randint(0, len(figures[shape]) - 1),
                'x': int(cup_w / 2) - int(fig_w / 2),
                'y': -2, 
                'color': random.randint(0, len(colors)-1)}
    return newFigure
#За добавление фигур к содержимому стакана отвечает addToCup():
def addToCup(cup, fig):
    for x in range(fig_w):
        for y in range(fig_h):
            if figures[fig['shape']][fig['rotation']][y][x] != empty:
                cup[x + fig['x']][y + fig['y']] = fig['color']
#Пустой стакан создается функцией emptycup():
def emptycup():
    # создает пустой стакан
    cup = []
    for i in range(cup_w):
        cup.append([empty] * cup_h)
    return cup
def incup(x, y):
    return x >= 0 and x < cup_w and y < cup_h
#Функция checkPos() следит за тем, чтобы падающая фигура оставалась в пределах игрового поля и не накладывалась на предыдущие. На примере слева фигура остается в допустимой области, на примере справа – ошибочно накладывается на предыдущую. Чтобы определить положение фигуры в стакане, нужно суммировать собственные координаты фигуры со «стаканными»:
def checkPos(cup, fig, adjX=0, adjY=0):
    # проверяет, находится ли фигура в границах стакана, не сталкиваясь с другими фигурами
    for x in range(fig_w):
        for y in range(fig_h):
            abovecup = y + fig['y'] + adjY < 0
            if abovecup or figures[fig['shape']][fig['rotation']][y][x] == empty:
                continue
            if not incup(x + fig['x'] + adjX, y + fig['y'] + adjY):
                return False
            if cup[x + fig['x'] + adjX][y + fig['y'] + adjY] != empty:
                return False
    return True
#За обнаружение и удаление заполненных рядов отвечает функция clearCompleted() вместе со вспомогательной isCompleted(). Если isCompleted() возвращает True, программе нужно последовательно переместить вниз все ряды, располагающиеся над удаляемым, после чего заполнить нулевой ряд empty-значениями о:
def isCompleted(cup, y):
    # проверяем наличие полностью заполненных рядов
    for x in range(cup_w):
        if cup[x][y] == empty:
            return False
    return True
def clearCompleted(cup):
    # Удаление заполенных рядов и сдвиг верхних рядов вниз
    removed_lines = 0
    y = cup_h - 1
    while y >= 0:
        if isCompleted(cup, y):
           for pushDownY in range(y, 0, -1):
                for x in range(cup_w):
                    cup[x][pushDownY] = cup[x][pushDownY-1]
           for x in range(cup_w):
                cup[x][0] = empty
           removed_lines += 1
        else:
            y -= 1
    return removed_lines
def convertCoords(block_x, block_y):
    return (side_margin + (block_x * block)), (top_margin + (block_y * block))
#Каждая фигура состоит из 4 элементов – блоков. Блоки рисует функция drawBlock(), которая получает координаты из convertCoords():
def drawBlock(block_x, block_y, color, pixelx=None, pixely=None):
    #отрисовка квадратных блоков, из которых состоят фигуры
    if color == empty:
        return
    if pixelx == None and pixely == None:
        pixelx, pixely = convertCoords(block_x, block_y)
    pg.draw.rect(display_surf, colors[color], (pixelx + 1, pixely + 1, block - 1, block - 1), 0, 3)
    pg.draw.rect(display_surf, lightcolors[color], (pixelx + 1, pixely + 1, block - 4, block - 4), 0, 3)
    pg.draw.circle(display_surf, colors[color], (pixelx + block / 2, pixely + block / 2), 5)
def gamecup(cup):
    # граница игрового поля-стакана
    pg.draw.rect(display_surf, brd_color, (side_margin - 4, top_margin - 4, (cup_w * block) + 8, (cup_h * block) + 8), 5)
    # фон игрового поля
    pg.draw.rect(display_surf, bg_color, (side_margin, top_margin, block * cup_w, block * cup_h))
    for x in range(cup_w):
        for y in range(cup_h):
            drawBlock(x, y, cup[x][y])
def drawTitle():
    titleSurf = big_font.render('Тетрис Lite', True, title_color)
    titleRect = titleSurf.get_rect()
    titleRect.topleft = (window_w - 425, 30)
    display_surf.blit(titleSurf, titleRect)
def drawInfo(points, level):
    pointsSurf = basic_font.render(f'Баллы: {points}', True, txt_color)
    pointsRect = pointsSurf.get_rect()
    pointsRect.topleft = (window_w - 550, 180)
    display_surf.blit(pointsSurf, pointsRect)
    levelSurf = basic_font.render(f'Уровень: {level}', True, txt_color)
    levelRect = levelSurf.get_rect()
    levelRect.topleft = (window_w - 550, 250)
    display_surf.blit(levelSurf, levelRect)
    pausebSurf = basic_font.render('Пауза: пробел', True, info_color)
    pausebRect = pausebSurf.get_rect()
    pausebRect.topleft = (window_w - 550, 420)
    display_surf.blit(pausebSurf, pausebRect)
    escbSurf = basic_font.render('Выход: Esc', True, info_color)
    escbRect = escbSurf.get_rect()
    escbRect.topleft = (window_w - 550, 450)
    display_surf.blit(escbSurf, escbRect)
def drawFig(fig, pixelx=None, pixely=None):
    figToDraw = figures[fig['shape']][fig['rotation']]
    if pixelx == None and pixely == None:    
        pixelx, pixely = convertCoords(fig['x'], fig['y'])
    #отрисовка элементов фигур
    for x in range(fig_w):
        for y in range(fig_h):
            if figToDraw[y][x] != empty:
                drawBlock(None, None, fig['color'], pixelx + (x * block), pixely + (y * block))
def drawnextFig(fig):  # превью следующей фигуры
    nextSurf = basic_font.render('Следующая:', True, txt_color)
    nextRect = nextSurf.get_rect()
    nextRect.topleft = (window_w - 150, 180)
    display_surf.blit(nextSurf, nextRect)
    drawFig(fig, pixelx=window_w-150, pixely=230)
if __name__ == '__main__':
    main()
Task:
шахматы.
Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли ладья попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом ладьи можно попасть во вторую, или «NO» в противном случае.
Decision:
x1,y1,x2,y2=int(input()),int(input()),int(input()),int(input())
if x1==x2 or y1==y2:
    print("YES")
else:    
    print("NO")
Task:
Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли король попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом короля можно попасть во вторую, или «NO» в противном случае.
Decision:
x1,y1,x2,y2=int(input()),int(input()),int(input()),int(input())
if (x2==x1+1 and y2==y1) or (x2==x1+1 and y2==y1-1) or (x2==x1+1 and y2==y1+1) or (x2==x1 and y2==y1+1) or (x2==x1 and y2==y1-1) or (x2==x1-1 and y2==y1) or (x2==x1-1 and y2==y1-1) or (x2==x1-1 and y2==y1+1):
    print("YES")
else:    
    print("NO")
Task:
Заданы две клетки шахматной доски. Напишите программу, которая определяет имеют ли указанные клетки один цвет или нет. Если они покрашены в один цвет, то выведите слово «YES», а если в разные цвета — то «NO».
Decision:
x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
if (x1 + y1 + x2 + y2) % 2 == 0:
    print('YES')
else:
    print('NO')
Task:
Даны две различные клетки шахматной доски. Напишите программу, которая определяет, может ли слон попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом слона можно попасть во вторую или «NO» в противном случае.
Decision:
x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
if (x1 - y1 == x2 - y2) or (x1 + y1 == x2 + y2):
    print('YES')
else:
    print('NO')
Task:
Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли конь попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом коня можно попасть во вторую или «NO» в противном случае.
Decision:
x1,y1,x2,y2= int(input()),int(input()),int(input()),int(input())
if (x2==x1-1 or x2==x1+1) and y2==y1-2:
    print('YES')
elif (x2==x1-2 or x2==x1+2) and y2==y1-1:
    print('YES')
elif (x2==x1-2 or x2==x1+2) and y2==y1+1:
    print('YES')
elif (x2==x1-1 or x2==x1+1) and y2==y1+2:
    print('YES')
else:
    print('NO')
Task:
Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли ферзь попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом ферзя можно попасть во вторую или «NO» в противном случае.
Decision:
x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
if (x1 - y1 == x2 - y2) or (x1 + y1 == x2 + y2):#слон
    print('YES')
elif (x1==x2 or x2==x1+1 or x2==x1-1) and (y1==y2 or y2==y1+1 or y2==y1-1): #король
    print('YES')
elif x1==x2 or y1==y2:#ладья
    print('YES')
else :
    print('NO')
Task:
Нарисуйте шахматную доску размера nхn, состоящую из нулей и единиц. Верхний левый символ должен быть единицей.
Примечание: между единицами и нулями в строке не должно быть пробелов, каждая строка должна быть на новой строке (в тестах отображается по-другому для экономии пространства).
Decision:
$ cat Py-Draft.py
n = int(input())
for i in range(n):
  row = ""
  for j in range(n):
    if (i+j)%2==0:
      row += "1"
    else:
      row += "0"
  print(row)
$ python3 Py-Draft.py
3
101
010
101
$ python3 Py-Draft.py
5
10101
01010
10101
01010
10101
$ python3 Py-Draft.py
6
101010
010101
101010
010101
101010
010101
Task:
Data Conversion.
Converting a dictionary list to html code. From this:
[{"A":"a_1", "B":"b_1", "C":"c_1"},
{"A":"a_2", "B":"b_2", "C":"c_2"}]
Convert to this:
<tr>
    <td>
        <select>
            <option value="A">
            A
            </option>
            <option value="a_1">
            a_1
            </option>
            <option value="a_2">
            a_2
            </option>
        </select>
    </td>
    <td>
        <select>
            <option value="B">
            B
            </option>
            <option value="b_1">
            b_1
            </option>
            <option value="b_2">
            b_2
            </option>
        </select>
    </td>
    <td>
        <select>
            <option value="C">
            C
            </option>
            <option value="c_1">
            c_1
            </option>
            <option value="c_2">
            c_2
            </option>
        </select>
    </td>
</tr>
<tr>
    <td>
        a_1
    </td>
    <td>
        b_1
    </td>
    <td>
        c_1
    </td>
</tr>
<tr>
    <td>
        a_2
    </td>
    <td>
        b_2
    </td>
    <td>
        c_2
    </td>
</tr>
Decision:
'''
listOfDictionaries = [
        {"A":"a_1", "B":"b_1", "C":"c_1"}, 
        {"A":"a_2", "B":"b_2", "C":"c_2"}
    ]
'''
listOfDictionaries=[]
listOfDictionaries.append({"A":"a_1", "B":"b_1", "C":"c_1"})
listOfDictionaries.append({"A":"a_2", "B":"b_2", "C":"c_2"})
'''
numb=int(input("Enter number: "))
for dictionary in range(1,numb):
    listOfDictionaries.append({"A":"a_$dictionary", "B":"b_$dictionary", "C":"c_$dictionary"})
    print(dictionary)
'''
'''
for dictionary in listOfDictionaries:
    #print(dictionary)
    #print(listOfDictionaries[0]['A'])
    for k in dictionary:
        print(k)
    for v in dictionary:
        print(dictionary[v])
'''
html="""{0}"""
tr="<tr>{0}</tr>"
td="<td>{0}</td>"
dictionary=[tr.format(''.join([td.format(a) for a in item])) for item in listOfDictionaries[:1]]
dictionary.extend([tr.format(''.join([td.format(item[a]) for a in item])) for item in listOfDictionaries])
print (html.format("".join(dictionary)))
Task:
Нужно чтобы на рабочем столе периодично отображались курсы доллара. заходим в центральный банк  смотрим курс валют, просмотрим тег. зацепимся именно за знак доллара, он один на этой странице. у него тег ins, и цепляюсь за него, потом есть родительский тег tr и забираю последний элемент td
Decision:
#!/usr/bin/python3.7
import requests #1 импортирую бибилиотеку, так как она будет отвечать за отправку запросов
from bs4 import BeautifulSoup
import os #26 отвечает за взаимодействие с ОС
def get_html(): #6 создаем фугкцию которая отправляет запрос
	url='http://www.cbr.ru/'
	r=requests.get(url) #8 делаем запрос на сервер
	return r.text #9 функция возвращает свойство text, уоторая содержит информацию об html
def get_dollar_rate(html): 
	soup = BeatifulSoup(html, 'lxml')
	# t = soup.find('ins', text='$') #13 ищем ins в теге tr 
	# t = soup.find('ins', text='$').find_parent('tr') #17 обратимся к его родительскому контейнеру tr
 	t = soup.find('ins', text='$').find_parent('tr').find_all('td')[-1].text #19 получим тег tr
	result=t.split('>')[-1] #21 указываем до какого числа нуно пропустить инфу (>) и какой элемент нам нужен (-1)
 	return result #23 получим число курс
def send_message(message): #24 хотим выводить это число на экран
 	title='dollar SHA:'
	#26 os.system('notify-send "title" "message"')
	os.system('notify-send "{}" "{}"'.format(title, message)) 
def main():
 	rate=get_dollar_rate(get_html()) #27 получаем курс доллара
 	send_message(rate)
if __name__ == '__main__':
	main()
Task:
Генерация.
Данная программа очень простая, она брет два случайных слова из файла words.txt и комбинирует их
Зачем это нужно?
При комбинировании слов включается фантазия, позволяющая представить какую вещь можно было бы создать, скомбинировав
два предмета или их свойства
Данный подход примняется в ТРИЗ для генерации идей, и изобретений
Decision:
import random#1 Импортируем библиотеку
mas=[]#2 создаем пустой список
f=open(u'words.txt', 'r')#3 Открываем файлы со словами (существит)
for x in f:#4 и в цикле
    mas.append(x.replace('\n',''))#5 добавляем их всех в массив, добавляя знак переноса строки
l=len(mas)-1#6 получаем длину этого массива
z=''
print('-----------------------------------------')
print('Генератор идей на основе случайного скрещивания предметов')#
print('-----------------------------------------')
print('Нажимайте Enter для генерации пар')#
print('\n')
while(z!='exit'):#7 и пока не напечатаем exit
    a=random.randint(0,l)#8 сгенерируем 2 случайных числа а
    b=random.randint(0,l)#8 и b с диапозоном от 0 до длина массива
    print(mas[a]+'-'+mas[b])# 9 и печатаем случайные строчки из файла words.txt после чего мы получаем различные комбинации случайных предметов
    z=input('')#    
Task:
Создание собстенного модуля
Для выполнения данного задания:
Создайте файл my_calc.py,
В этом файле напишите функцию calc_sum, которая на вход принимает два целых числа и возвращает их сумму. Пропишите аннотации к переменным, а также докстринг для функции,
Загрузите файл во временное сессионное хранилище Google Colab
Импортируйте файл в ноутбук:
import my_calc
Воспользуйтесь вашей функцией для сложения двух чисел: 10 и 5
Выведите результат на экран
Decision:
$ touch my_calc.py
$ cat my_calc.py 
def calc_sum(oper1: int = 20, oper2: int = 30) -> int:
    """_summary_
    This method returns sum of 2 input arguments
    """
    total_sum = oper1 + oper2
    return total_sum                                                                                                                
$ cat test.py            
import my_calc as mc
print(mc.calc_sum())
$ /bin/python3.11 test.py
50